<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoChat</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="app-header">
        <div class="app-logo">CoChat</div>
        <div class="header-controls">
            <!-- Remove the speaker icon button from navigation -->
            <!-- <button class="header-btn" id="muteButton"><i class="bi bi-volume-up"></i></button> -->
            <button class="header-btn" id="exportButton" title="Generate Summary"><i class="bi bi-card-text"></i></button>
            <div class="position-relative dropdown">
                <button class="header-btn d-flex align-items-center gap-2" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                    <span id="currentMode">Individual</span>
                    <i class="bi bi-chevron-down"></i>
                </button>
                <ul class="dropdown-menu dropdown-menu-dark">
                    <li><a class="dropdown-item" href="#" data-mode="individual"><i class="bi bi-person me-2"></i>Individual</a></li>
                    <li><a class="dropdown-item" href="#" data-mode="sequential"><i class="bi bi-list-ol me-2"></i>Sequential</a></li>
                    <li><a class="dropdown-item" href="#" data-mode="parallel"><i class="bi bi-columns-gap me-2"></i>Parallel</a></li>
                    <li><a class="dropdown-item" href="#" data-mode="cyclic"><i class="bi bi-arrow-repeat me-2"></i>Cyclic</a></li>
                </ul>
                </div>
            <button class="add-panel-btn" id="addAssistant"><i class="bi bi-plus"></i> Add Panel</button>
            <button class="header-btn" id="settingsButton" onclick="openSettings()"><i class="bi bi-gear"></i></button>
            </div>
        </div>

    <!-- Hidden select to maintain compatibility with existing JavaScript -->
    <select id="processingMode" style="display: none;">
        <option value="individual" selected>Individual</option>
        <option value="sequential">Sequential</option>
        <option value="parallel">Parallel</option>
        <option value="cyclic">Cyclic</option>
    </select>

        <div id="assistantsContainer">
            <!-- Template for assistant panel -->
            <div class="chat-panel" id="assistant-1">
                <div class="panel-header">
                <h5 class="panel-title"></h5>
                <div class="panel-header-controls">
                    <button class="btn-clear" onclick="clearChat(this)" title="Clear chat">
                        <i class="bi bi-trash"></i>
                    </button>
                    <button class="btn-close" onclick="removeAssistant(this.closest('.chat-panel').id)" title="Close panel">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
                </div>
                <div class="model-config">
                <div class="d-flex align-items-center justify-content-between px-3 py-2">
                            <select class="model-select cyber-pill" onchange="handleModelChange(this)">
                            <option value="">Select Model</option>
                        </select>
                    <div class="form-check form-switch ms-3">
                        <input class="form-check-input stream-toggle" type="checkbox" id="streamToggle-1" checked>
                        <label class="form-check-label" for="streamToggle-1">Enable Streaming</label>
                        </div>
                    </div>
                </div>
                <div class="chat-window" id="chat-1"></div>
                <div class="panel-controls">
                <div>
                    <textarea class="prompt-input" rows="2" placeholder="Type your message..."></textarea>
                    <div class="d-flex align-items-center gap-2 mt-2">
                        <select class="posture-select" style="max-width: 180px;">
                            <option value="professional">Professional</option>
                            <option value="academic">Academic & Scholarly</option>
                            <option value="analytical">Analytical & Methodical</option>
                            <option value="casual">Casual & Friendly</option>
                            <option value="concise" selected>Concise & Direct</option>
                            <option value="creative">Creative & Imaginative</option>
                        </select>
                        <select class="role-select" style="max-width: 130px;">
                            <option value="researcher">Researcher</option>
                            <option value="analyst">Data Analyst</option>
                            <option value="assistant">General Assistant</option>
                            <option value="coder">Code Assistant</option>
                            <option value="expert">Domain Expert</option>
                            <option value="technical">Technical Expert</option>
                            <option value="writer">Writer</option>
                        </select>
                        <div class="ms-auto d-flex gap-2">
                            <input type="file" class="file-input" accept="image/*,.pdf" style="display: none;">
                            <button class="btn btn-sm btn-outline-secondary upload-btn" title="Upload File/Image">
                                <i class="bi bi-upload"></i>
                            </button>
                            <button class="send-button">Send</button>
                            <button class="stop-button" style="display: none;">Stop</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">LM Studio Servers</label>
                        <div id="serverList" class="mb-2">
                            <!-- Server entries will be added here -->
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-primary" onclick="addServerEntry()">
                            <i class="bi bi-plus-circle"></i> Add Server
                        </button>
                    </div>
                    <div class="mb-3 d-flex align-items-center justify-content-between">
                        <label class="form-label mb-0">Theme</label>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="themeToggle">
                            <label class="form-check-label" for="themeToggle" id="themeToggleLabel">Night</label>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn header-btn" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn add-panel-btn" onclick="saveSettings()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Summary Modal -->
    <div class="modal fade" id="summaryModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Generate Summary</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="summaryModel" class="form-label">Select Model for Summary</label>
                        <select class="form-select" id="summaryModel">
                            <!-- Models will be populated here -->
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="summaryType" class="form-label">Summary Type</label>
                        <select class="form-select" id="summaryType">
                            <option value="concise">Concise Summary</option>
                            <option value="detailed">Detailed Summary</option>
                            <option value="whatsapp">WhatsApp Style</option>
                            <option value="bullet">Bullet Points</option>
                            <option value="executive">Executive Summary</option>
                        </select>
                    </div>
                    <div id="summarySpinner" class="text-center" style="display: none;">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <div id="summaryResult" style="display: none;">
                        <h5>Summary:</h5>
                        <div id="summaryContent" class="border p-3 rounded bg-light"></div>
                        <button id="copySummaryBtn" class="btn btn-sm btn-outline-primary mt-2">
                            <i class="bi bi-clipboard"></i> Copy
                        </button>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn header-btn" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn add-panel-btn" id="generateSummaryBtn">Generate Summary</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let assistantCount = 1;
        let server_url = localStorage.getItem('lmStudioUrl') || 'http://192.168.50.10:3500';
        
        // Initialize when document is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Document ready, initializing app...");
            
            // Load saved servers from local storage or set default
            const savedServers = JSON.parse(localStorage.getItem('lmStudioServers') || '[]');
            if (savedServers.length === 0) {
                // Save default server if no servers are saved
                localStorage.setItem('lmStudioServers', JSON.stringify([server_url]));
                
                // Save to server immediately
                fetch('/save_settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        lm_url: server_url
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Default settings saved successfully:", data);
                    // Initial fetch of models with retries
            fetchModels();
                })
                .catch(error => {
                    console.error('Error saving default settings:', error);
                    // Still try to fetch models even if settings save fails
                    fetchModels();
                });
            } else {
                // Use the first saved server as primary
                server_url = savedServers[0];
                // Initial fetch of models with retries
                fetchModels();
            }
            
            // Setup periodic refresh of models every 30 seconds
            setInterval(() => {
                fetchModels();
            }, 30000);
            
            // Setup event listeners for initial panel
            const initialPanel = document.getElementById('assistant-1');
            setupMessageHandlers(initialPanel);
            setupUploadHandlers(initialPanel);
            
            // Make upload button visible by default
            const uploadBtn = initialPanel.querySelector('.upload-btn');
            if (uploadBtn) {
                uploadBtn.style.display = 'inline-flex';
            }

            // Setup chat mode handlers
            setupChatModeHandlers();
            
            // Setup summary button handler
            const exportButton = document.getElementById('exportButton');
            if (exportButton) {
                exportButton.onclick = openSummaryModal;
            }

            // Setup Add Panel button handler
            const addPanelButton = document.getElementById('addAssistant');
            if (addPanelButton) {
                addPanelButton.onclick = addAssistant;
            }
            
            // Theme toggle logic
            const themeToggle = document.getElementById('themeToggle');
            const themeToggleLabel = document.getElementById('themeToggleLabel');
            const root = document.documentElement;
            const body = document.body;
            function applyTheme(theme) {
                if (theme === 'dark') {
                    root.classList.add('dark-mode');
                    root.classList.remove('light-mode');
                    body.classList.add('dark-mode');
                    body.classList.remove('light-mode');
                    if (themeToggle) themeToggle.checked = true;
                    if (themeToggleLabel) themeToggleLabel.textContent = 'Night';
                } else {
                    root.classList.remove('dark-mode');
                    root.classList.add('light-mode');
                    body.classList.remove('dark-mode');
                    body.classList.add('light-mode');
                    if (themeToggle) themeToggle.checked = false;
                    if (themeToggleLabel) themeToggleLabel.textContent = 'Day';
                }
            }
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);
            if (themeToggle) {
                themeToggle.addEventListener('change', function() {
                    const theme = this.checked ? 'dark' : 'light';
                    localStorage.setItem('theme', theme);
                    applyTheme(theme);
                });
            }
            
            // Rest of your initialization code...
        });
        
        // Function to add a new server entry
        function addServerEntry(url = '') {
            const serverList = document.getElementById('serverList');
            const serverEntry = document.createElement('div');
            serverEntry.className = 'input-group mb-2';
            serverEntry.innerHTML = `
                <input type="text" class="form-control server-url" value="${url}" placeholder="Enter server URL">
                <button class="btn btn-outline-danger" onclick="this.closest('.input-group').remove()">
                    <i class="bi bi-trash"></i>
                </button>
            `;
            serverList.appendChild(serverEntry);
        }
        
        // Function to open settings modal
        function openSettings() {
            // Clear existing server entries
            const serverList = document.getElementById('serverList');
            serverList.innerHTML = '';
            
            // Load saved servers from local storage
            const savedServers = JSON.parse(localStorage.getItem('lmStudioServers') || '[]');
            if (savedServers.length === 0) {
                // Add default server if no servers are saved
                addServerEntry('http://172.17.64.1:3500');
            } else {
                savedServers.forEach(server => addServerEntry(server));
            }
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('settingsModal'));
            modal.show();
        }
        
        // Function to save settings
        function saveSettings() {
            // Save server URLs
            const serverUrls = Array.from(document.querySelectorAll('.server-url'))
                .map(input => input.value.trim())
                .filter(url => url !== '');
            
            localStorage.setItem('lmStudioServers', JSON.stringify(serverUrls));
            server_url = serverUrls[0]; // Use first server as primary
            
            // Save to server
            fetch('/save_settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    lm_url: server_url
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.message || 'Failed to save settings');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log("Settings saved successfully:", data);
                showToast('Settings saved successfully', 'success');
                
                // Reload models with the new URL
                fetchModels();
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
                modal.hide();
            })
            .catch(error => {
                console.error('Error saving settings:', error);
                showToast('Failed to save settings: ' + error.message, 'error');
            });
        }
        
        // Function to check if a model supports vision capabilities
        function isVisionModel(model) {
            if (!model || typeof model !== 'object') return false;
            
            // Check model ID and capabilities
            const modelId = model.id.toLowerCase();
            const visionKeywords = ['vision', 'vl', 'visual', 'multimodal', 'llava', 'qwen-vl', 'bakllava', 'obsidian'];
            return visionKeywords.some(keyword => modelId.includes(keyword));
        }

        // Function to update upload controls visibility
        function updateUploadControls() {
            document.querySelectorAll('.chat-panel').forEach(panel => {
                const modelSelect = panel.querySelector('.model-select');
                const selectedModel = modelSelect.value;
                const model = window.availableModels?.find(m => m.id === selectedModel);
                
                const uploadBtn = panel.querySelector('.upload-btn');
                const uploadInput = panel.querySelector('.file-input');
                
                if (uploadBtn && uploadInput) {
                    // Always show upload button, we'll handle capability checks when files are selected
                    uploadBtn.style.display = 'block';
                    
                    // Update button tooltip based on model capabilities
                    if (model && isVisionModel(model)) {
                        uploadBtn.title = 'Upload File/Image (Vision Capable)';
                        uploadInput.accept = '*/*';  // Accept all files
                    } else {
                        uploadBtn.title = 'Upload File (No Vision Support)';
                        uploadInput.accept = '*/*';  // Accept all files
                    }
                }
            });
        }

        // Function to handle model change
        function handleModelChange(select) {
            const panel = select.closest('.chat-panel');
            const selectedModel = select.value;
            const model = window.availableModels?.find(m => m.id === selectedModel);
            
            // Update upload buttons visibility based on model capabilities
            if (model) {
                const uploadBtn = panel.querySelector('.upload-btn');
                const uploadInput = panel.querySelector('.upload-input');
                const enableFileUpload = localStorage.getItem('enableFileUpload') === 'true';
                const enableImageUpload = localStorage.getItem('enableImageUpload') === 'true';
                
                if (uploadBtn) {
                    const showUpload = enableFileUpload || (enableImageUpload && isVisionModel(model));
                    uploadBtn.style.display = showUpload ? 'block' : 'none';
                    
                    // Update accept attribute based on capabilities
                    if (uploadInput) {
                        if (enableFileUpload && enableImageUpload && model && isVisionModel(model)) {
                            uploadInput.accept = '*/*';
                        } else if (enableImageUpload && model && isVisionModel(model)) {
                            uploadInput.accept = 'image/*';
                        } else if (enableFileUpload) {
                            uploadInput.accept = '*/*';
                        }
                    }
                }
            }
        }
        
        // Function to create a new assistant panel
        function addAssistant() {
            // Find the active panel (panel with focus or last interacted panel)
            let activePanel = document.activeElement ? 
                document.activeElement.closest('.chat-panel') : null;
            
            if (!activePanel) {
                // Try to find a panel with a visible stop button (currently processing)
                const activePanels = Array.from(document.querySelectorAll('.chat-panel')).filter(panel => 
                    panel.querySelector('.stop-button').style.display !== 'none'
                );
                
                if (activePanels.length > 0) {
                    activePanel = activePanels[0];
                } else {
                    // Fallback to the first panel
                    activePanel = document.querySelector('.chat-panel');
                }
            }
            
            // Get settings from active panel
            let activeSettings = {
                model: "",
                role: "researcher",
                posture: "professional",
                streamEnabled: false
            };
            
            if (activePanel) {
                const modelSelect = activePanel.querySelector('.model-select');
                const roleSelect = activePanel.querySelector('.role-select');
                const postureSelect = activePanel.querySelector('.posture-select');
                const streamToggle = activePanel.querySelector('.stream-toggle');
                
                activeSettings = {
                    model: modelSelect ? modelSelect.value : "",
                    role: roleSelect ? roleSelect.value : "researcher",
                    posture: postureSelect ? postureSelect.value : "professional",
                    streamEnabled: streamToggle ? streamToggle.checked : false
                };
                
                console.log("Cloning settings from active panel:", activeSettings);
            }
            
            assistantCount++;
            const newAssistant = createAssistantPanel(assistantCount, activeSettings);
            document.getElementById('assistantsContainer').appendChild(newAssistant);
            setupMessageHandlers(newAssistant);
            populateModelSelect(newAssistant.querySelector('.model-select'), activeSettings.model);
        }
        
        // Function to create a new assistant panel
        function createAssistantPanel(id, settings = null) {
            const panel = document.createElement('div');
            panel.className = 'chat-panel';
            panel.id = `assistant-${id}`;
            
            // Use provided settings or defaults
            const defaultSettings = {
                model: "",
                role: "researcher",
                posture: "professional",
                streamEnabled: false
            };
            
            const panelSettings = settings || defaultSettings;
            const { role, posture, streamEnabled } = panelSettings;
            
            panel.innerHTML = `
                <div class="panel-header">
                    <h5 class="panel-title"></h5>
                    <div class="panel-header-controls">
                        <button class="btn-clear" onclick="clearChat(this)" title="Clear chat">
                            <i class="bi bi-trash"></i>
                        </button>
                        <button class="btn-close" onclick="removeAssistant(this.closest('.chat-panel').id)" title="Close panel">
                            <i class="bi bi-x-lg"></i>
                        </button>
                    </div>
                </div>
                <div class="model-config">
                    <div class="d-flex align-items-center justify-content-between px-3 py-2">
                        <select class="model-select" onchange="handleModelChange(this)">
                            <option value="">Select Model</option>
                        </select>
                        <div class="form-check form-switch ms-3">
                            <input class="form-check-input stream-toggle" type="checkbox" id="streamToggle-${id}" ${streamEnabled ? 'checked' : ''}>
                            <label class="form-check-label" for="streamToggle-${id}">Enable Streaming</label>
                        </div>
                    </div>
                </div>
                <div class="chat-window" id="chat-${id}"></div>
                <div class="panel-controls">
                    <div>
                        <textarea class="prompt-input" rows="2" placeholder="Type your message..."></textarea>
                        <div class="d-flex align-items-center gap-2 mt-2">
                            <select class="posture-select" style="max-width: 180px;">
                                <option value="professional" ${posture === 'professional' ? 'selected' : ''}>Professional</option>
                                <option value="academic" ${posture === 'academic' ? 'selected' : ''}>Academic & Scholarly</option>
                                <option value="analytical" ${posture === 'analytical' ? 'selected' : ''}>Analytical & Methodical</option>
                                <option value="casual" ${posture === 'casual' ? 'selected' : ''}>Casual & Friendly</option>
                                <option value="concise" ${posture === 'concise' ? 'selected' : ''}>Concise & Direct</option>
                                <option value="creative" ${posture === 'creative' ? 'selected' : ''}>Creative & Imaginative</option>
                            </select>
                            <select class="role-select" style="max-width: 130px;">
                                <option value="researcher" ${role === 'researcher' ? 'selected' : ''}>Researcher</option>
                                <option value="analyst" ${role === 'analyst' ? 'selected' : ''}>Data Analyst</option>
                                <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>General Assistant</option>
                                <option value="coder" ${role === 'coder' ? 'selected' : ''}>Code Assistant</option>
                                <option value="expert" ${role === 'expert' ? 'selected' : ''}>Domain Expert</option>
                                <option value="technical" ${role === 'technical' ? 'selected' : ''}>Technical Expert</option>
                                <option value="writer" ${role === 'writer' ? 'selected' : ''}>Writer</option>
                            </select>
                            <div class="ms-auto d-flex gap-2">
                                <input type="file" class="file-input" accept="image/*,.pdf" style="display: none;">
                                <button class="btn btn-sm btn-outline-secondary upload-btn" title="Upload File/Image">
                                    <i class="bi bi-upload"></i>
                                </button>
                                <button class="send-button">Send</button>
                                <button class="stop-button" style="display: none;">Stop</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Setup upload handlers
            setupUploadHandlers(panel);
            
            // Update upload controls visibility
            updateUploadButtonVisibility(panel);
            
            return panel;
        }
        
        // Function to setup upload handlers
        function setupUploadHandlers(panel) {
            const uploadBtn = panel.querySelector('.upload-btn');
            const fileInput = panel.querySelector('.file-input');
            
            if (uploadBtn && fileInput) {
                // Always show upload button
                uploadBtn.style.display = 'inline-flex';
                
                uploadBtn.addEventListener('click', () => {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', async (e) => {
                    const files = e.target.files;
                    if (!files || files.length === 0) return;
                    
                    const file = files[0];
                    const modelSelect = panel.querySelector('.model-select');
                    const selectedModel = modelSelect.value;
                    const model = window.availableModels?.find(m => m.id === selectedModel);
                    
                    // Show upload progress in the chat window
                    const chatWindow = panel.querySelector('.chat-window');
                    const progressDiv = document.createElement('div');
                    progressDiv.className = 'message upload-progress-message';
                    progressDiv.innerHTML = `
                        <div class="message-content">
                            <div class="progress">
                                <div class="progress-bar" role="progressbar" style="width: 0%"></div>
                            </div>
                            <small class="text-muted">Uploading ${file.name}...</small>
                        </div>
                    `;
                    chatWindow.appendChild(progressDiv);
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                    
                    try {
                        const formData = new FormData();
                        formData.append('file', file);
                        
                        const response = await fetch('/upload', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // Update progress bar
                            progressDiv.querySelector('.progress-bar').style.width = '100%';
                            progressDiv.querySelector('.progress-bar').className = 'progress-bar bg-success';
                            
                            // Create file preview message
                            const fileMessage = document.createElement('div');
                            fileMessage.className = 'message file-message';
                            
                            if (result.type === 'image') {
                                // For images, show thumbnail
                                fileMessage.innerHTML = `
                                    <div class="message-content">
                                        <div class="file-preview">
                                            <img src="/file/${result.file_id}" alt="${file.name}" class="file-thumbnail">
                                            <div class="file-info">
                                                <div class="file-name">${file.name}</div>
                                                <div class="file-size">${formatFileSize(file.size)}</div>
                                            </div>
                                        </div>
                                        <div class="file-reference">[Image:${result.file_id}]</div>
                                    </div>
                                `;
                            } else if (result.type === 'pdf') {
                                // For PDFs, show icon and info
                                fileMessage.innerHTML = `
                                    <div class="message-content">
                                        <div class="file-preview">
                                            <i class="bi bi-file-pdf text-danger"></i>
                                            <div class="file-info">
                                                <div class="file-name">${file.name}</div>
                                                <div class="file-size">${formatFileSize(file.size)}</div>
                                            </div>
                                        </div>
                                        <div class="file-reference">[PDF:${result.file_id}]</div>
                                    </div>
                                `;
                            }
                            
                            // Replace progress message with file preview
                            progressDiv.replaceWith(fileMessage);
                            
                            // Add file reference to message input
                            const messageInput = panel.querySelector('.prompt-input');
                            const fileRef = result.type === 'pdf' ? `[PDF:${result.file_id}]` : `[Image:${result.file_id}]`;
                            messageInput.value += (messageInput.value ? ' ' : '') + fileRef;
                            
                            // Scroll to show the new message
                            chatWindow.scrollTop = chatWindow.scrollHeight;
                        } else {
                            throw new Error(result.error || 'Upload failed');
                        }
                    } catch (error) {
                        console.error('Upload error:', error);
                        progressDiv.querySelector('.progress-bar').className = 'progress-bar bg-danger';
                        progressDiv.querySelector('.progress-bar').style.width = '100%';
                        progressDiv.querySelector('small').textContent = `Error: ${error.message}`;
                        
                        // Remove error message after 3 seconds
                        setTimeout(() => {
                            progressDiv.remove();
                        }, 3000);
                    }
                    
                    // Reset file input
                    fileInput.value = '';
                });
            }
        }
        
        // Add helper function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Add styles for file preview
        const filePreviewStyle = document.createElement('style');
        filePreviewStyle.textContent = `
            .file-message {
                margin: 10px 0;
            }
            
            .file-preview {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 10px;
                background: #f8f9fa;
                border-radius: 8px;
                margin-bottom: 5px;
            }
            
            .file-thumbnail {
                max-width: 100px;
                max-height: 100px;
                object-fit: contain;
                border-radius: 4px;
            }
            
            .file-info {
                flex: 1;
            }
            
            .file-name {
                font-weight: 500;
                margin-bottom: 2px;
            }
            
            .file-size {
                font-size: 0.8em;
                color: #6c757d;
            }
            
            .file-reference {
                font-size: 0.8em;
                color: #6c757d;
                margin-top: 5px;
            }
            
            .upload-progress-message {
                margin: 10px 0;
            }
            
            .upload-progress-message .progress {
                height: 4px;
                margin-bottom: 5px;
            }
            
            .upload-progress-message small {
                display: block;
                text-align: center;
            }
        `;
        document.head.appendChild(filePreviewStyle);
        
        // Function to show toast message
        function showToast(message, type = 'error') {
            const toastContainer = document.querySelector('.toast-container') || (() => {
                const container = document.createElement('div');
                container.className = 'toast-container';
                document.body.appendChild(container);
                return container;
            })();

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <i class="bi bi-exclamation-circle"></i>
                <span>${message}</span>
                <span class="close-btn" onclick="this.parentElement.remove()">Ã—</span>
            `;

            toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 5000);
        }

        // Function to handle file/image upload
        function handleUpload() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showMessage('Please select a file to upload', 'error');
                return;
            }
            
            // Check file type
            const fileType = file.type.toLowerCase();
            const fileExtension = file.name.toLowerCase().split('.').pop();
            
            if (!['application/pdf', 'image/jpeg', 'image/png', 'image/gif', 'image/webp'].includes(fileType) && 
                !['pdf', 'jpg', 'jpeg', 'png', 'gif', 'webp'].includes(fileExtension)) {
                showMessage('Invalid file type. Please upload a PDF or image file.', 'error');
                return;
            }
            
            // Get the upload button and show loading state
            const uploadButton = document.getElementById('uploadButton');
            const originalButtonContent = uploadButton.innerHTML;
            uploadButton.disabled = true;
            uploadButton.innerHTML = '<i class="bi bi-hourglass-split"></i> Processing...';
            
            // Create FormData and append file
            const formData = new FormData();
            formData.append('file', file);
            
            // Show progress indicator
            const progressDiv = document.createElement('div');
            progressDiv.className = 'upload-progress';
            progressDiv.innerHTML = `
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div class="progress-text">Processing ${file.name}...</div>
            `;
            document.body.appendChild(progressDiv);
            
            // Send the file with progress tracking
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Upload failed: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Update message input with file reference
                    const messageInput = document.getElementById('messageInput');
                    const fileReference = data.type === 'pdf' ? `[PDF:${data.file_id}]` : `[Image:${data.file_id}]`;
                    messageInput.value = fileReference;
                    
                    // Show success message
                    showMessage('File uploaded successfully!', 'success');
                    
                    // Update progress bar to complete
                    progressDiv.querySelector('.progress-fill').style.width = '100%';
                    progressDiv.querySelector('.progress-text').textContent = 'Upload complete!';
                    
                    // Remove progress bar after a delay
                    setTimeout(() => {
                        progressDiv.remove();
                    }, 1000);
                } else {
                    throw new Error(data.error || 'Upload failed');
                }
            })
            .catch(error => {
                console.error('Upload error:', error);
                showMessage('Error uploading file: ' + error.message, 'error');
                progressDiv.remove();
            })
            .finally(() => {
                // Reset upload button
                uploadButton.disabled = false;
                uploadButton.innerHTML = originalButtonContent;
            });
        }
        
        // Function to remove an assistant panel
        function removeAssistant(assistantId) {
            const panel = document.getElementById(assistantId);
            if (panel) {
                    panel.remove();
                        adjustPanelWidths();
                    }
        }
        
        // Function to adjust panel widths based on number of panels
        function adjustPanelWidths() {
            const container = document.getElementById('assistantsContainer');
            const panels = container.querySelectorAll('.chat-panel');
            
            // If more than 3 panels, set to a percentage with a minimum width
            if (panels.length > 3) {
                const width = Math.max(30, 100 / panels.length);
                panels.forEach(panel => {
                    panel.style.width = `${width}%`;
                    panel.style.flex = '0 0 auto';
                });
            } else {
                panels.forEach(panel => {
                    panel.style.width = '';
                    panel.style.flex = '1';
                });
            }
        }
        
        // Function to set up message handlers
        function setupMessageHandlers(panel) {
            const textarea = panel.querySelector('.prompt-input');
            const sendButton = panel.querySelector('.send-button');
            const roleSelect = panel.querySelector('.role-select');
            const postureSelect = panel.querySelector('.posture-select');
            const panelTitle = panel.querySelector('.panel-header h5');
            
            // Set initial panel title
            updatePanelTitle(panel);
            
            // Add listeners for role and posture changes to update panel title
            roleSelect.addEventListener('change', function() {
                updatePanelTitle(panel);
            });
            
            postureSelect.addEventListener('change', function() {
                updatePanelTitle(panel);
            });
            
            // Enter key handler
            textarea.addEventListener('keydown', function(e) {
                console.log("Key pressed in textarea:", e.key);
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage(sendButton);
                }
            });

            // Send button handler
            sendButton.addEventListener('click', function() {
                console.log("Send button clicked");
                sendMessage(this);
            });
            
            // Auto-resize the textarea
            textarea.addEventListener('input', function() {
                // Keep fixed height and enable scrolling
                this.style.height = '60px';
                this.style.overflowY = 'auto';
            });
        }
        
        // Function to update panel title based on role and posture
        function updatePanelTitle(panel) {
            const roleSelect = panel.querySelector('.role-select');
            const postureSelect = panel.querySelector('.posture-select');
            const panelTitle = panel.querySelector('.panel-header h5');
            
            if (roleSelect && postureSelect && panelTitle) {
                const role = roleSelect.options[roleSelect.selectedIndex].textContent.toLowerCase();
                const posture = postureSelect.options[postureSelect.selectedIndex].textContent.toLowerCase();
                panelTitle.textContent = `${posture} ${role}`;
            }
        }
        
        // Function to handle message sending
        async function sendMessage(button) {
            const panel = button.closest('.chat-panel');
            if (!panel) {
                console.error("Cannot find parent panel for send button");
                return;
            }
            
            const textarea = panel.querySelector('.prompt-input');
            const chatWindow = panel.querySelector('.chat-window');
            const sendButton = panel.querySelector('.send-button');
            const stopButton = panel.querySelector('.stop-button');
            const modelSelect = panel.querySelector('.model-select');
            const roleSelect = panel.querySelector('.role-select');
            const postureSelect = panel.querySelector('.posture-select');
            const streamEnabled = panel.querySelector('.stream-toggle').checked;
            
            const message = textarea.value.trim();
            if (!message) return;
            
            // Check if we can send in sequential mode
            const processingMode = document.getElementById('processingMode').value;
            if (processingMode === 'sequential' && !canSendInSequentialMode(panel)) {
                alert('In sequential mode, you must wait for the previous assistant to finish.');
                return;
            }

            // Clear the input
            textarea.value = '';
            
            // Add the user message to the chat
            const userMessageElement = createMessageWithCopy(message, 'user-message');
            chatWindow.appendChild(userMessageElement);
            chatWindow.scrollTop = chatWindow.scrollHeight;
            
            // Check if the message contains an image
            const hasImage = message.includes('[Image:');
            if (hasImage) {
                // Create and add the analyzing animation
                const analyzingElement = document.createElement('div');
                analyzingElement.className = 'analyzing-container';
                analyzingElement.innerHTML = `
                    <div class="analyzing-text">Analyzing image...</div>
                    <div class="bouncing-balls">
                        <div class="bouncing-ball"></div>
                        <div class="bouncing-ball"></div>
                        <div class="bouncing-ball"></div>
                    </div>
                `;
                chatWindow.appendChild(analyzingElement);
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
            
            // Disable the send button, show stop button
            sendButton.disabled = true;
            stopButton.style.display = 'block';

            // Prepare the data
            const model = modelSelect.value;
            const role = roleSelect.value;
            const posture = postureSelect.value;
            
            // Send the message to the server
            let controller = new AbortController();
            const signal = controller.signal;
            
            // Set up the abort function
            stopButton.onclick = function() {
                controller.abort();
                stopButton.style.display = 'none';
                sendButton.disabled = false;
                
                // Remove analyzing animation if it exists
                const analyzingElement = chatWindow.querySelector('.analyzing-container');
                if (analyzingElement) {
                    analyzingElement.remove();
                }
                
                // Dispatch event to notify that the response is complete
                const event = new CustomEvent('responseComplete', {
                    detail: { panelId: panel.id }
                });
                document.dispatchEvent(event);
            };
            
            console.log('Sending chat request:', {
                model,
                role,
                posture,
                streamEnabled,
                messageLength: message.length
            });
            
            try {
                const response = await fetch('/chat', {
                method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message,
                        model: model,
                        stream: streamEnabled,
                        temperature: 0.7,
                        max_tokens: 2000,
                        top_p: 0.95,
                        frequency_penalty: 0,
                        presence_penalty: 0,
                        stop: [],
                        mode: processingMode,
                        posture: posture,
                        role: role
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                if (streamEnabled) {
                    // Handle streaming response
                    await handleStreamResponse(response, chatWindow, panel);
                } else {
                    // Handle non-streaming response
                    const data = await response.json();
                        if (data.error) {
                            throw new Error(data.error);
                        }
                    if (data.choices && data.choices[0]) {
                        const content = data.choices[0].message.content;
                        const assistantMessage = createMessageWithCopy(content, 'assistant-message');
                        assistantMessage.dataset.panelId = panel.id;
                        chatWindow.appendChild(assistantMessage);
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                    } else {
                        throw new Error('Invalid response format from server');
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                    const errorMessage = createMessageWithCopy('Error: ' + error.message, 'error-message');
                    chatWindow.appendChild(errorMessage);
                    chatWindow.scrollTop = chatWindow.scrollHeight;
            } finally {
                // Re-enable the send button, hide stop button
                sendButton.disabled = false;
                stopButton.style.display = 'none';
                
                // Remove analyzing animation if it exists
                const analyzingElement = chatWindow.querySelector('.analyzing-container');
                if (analyzingElement) {
                    analyzingElement.remove();
                }
                
                // Dispatch event to notify that the response is complete
                const event = new CustomEvent('responseComplete', {
                    detail: { panelId: panel.id }
                });
                document.dispatchEvent(event);
            }
        }
        
        // Function to check if we can send in sequential mode
        function canSendInSequentialMode(currentPanel) {
            const processingMode = document.getElementById('processingMode').value;
            console.log("Checking if can send in sequential mode. Current mode:", processingMode);
            
            // If not in sequential mode, always allow
            if (processingMode !== 'sequential') {
                console.log("Not in sequential mode, allowing send");
                return true;
            }
            
            // Get all panels
            const panels = Array.from(document.querySelectorAll('.chat-panel'));
            const currentIndex = panels.indexOf(currentPanel);
            console.log("Current panel index:", currentIndex, "Total panels:", panels.length);
            
            // First panel can always send
            if (currentIndex === 0) {
                console.log("First panel, allowing send");
                return true;
            }
            
            // Check if the previous panel has received a response
            const previousPanel = panels[currentIndex - 1];
            const previousPanelMessages = previousPanel.querySelectorAll('.message');
            console.log("Previous panel has", previousPanelMessages.length, "messages");
            
            // If the previous panel has no messages at all, we can't send
            if (previousPanelMessages.length === 0) {
                console.log("Previous panel has no messages, blocking send");
                return false;
            }
            
            // Check if the last message in the previous panel is from the assistant
            const lastMessage = previousPanelMessages[previousPanelMessages.length - 1];
            const isLastMessageFromAssistant = !lastMessage.classList.contains('user-message');
            console.log("Last message is from assistant:", isLastMessageFromAssistant);
            
            // Check if there's a pending response in the previous panel
            const previousStopButton = previousPanel.querySelector('.stop-button');
            const hasPendingResponse = previousStopButton && previousStopButton.style.display !== 'none';
            console.log("Previous panel has pending response:", hasPendingResponse);
            
            // Can send if the last message is from the assistant and there's no pending response
            const canSend = isLastMessageFromAssistant && !hasPendingResponse;
            console.log("Can send in sequential mode:", canSend);
            return canSend;
        }

        // Function to set up sequential monitoring
        function setupSequentialMonitoring() {
            console.log("Setting up sequential monitoring");
            
            // Remove existing event listener if any
            document.removeEventListener('responseComplete', handleResponseComplete);
            
            // Add new event listener
            document.addEventListener('responseComplete', handleResponseComplete);
            
            // Log that the event listener is registered
            console.log("Sequential mode event listener registered");
        }
        
        // Function to handle response complete event
        function handleResponseComplete(e) {
            console.log("Response complete event received for panel:", e.detail.panelId);
            
            const processingMode = document.getElementById('processingMode').value;
            console.log("Current processing mode:", processingMode);
            
            if (processingMode !== 'sequential') {
                console.log("Not in sequential mode, ignoring response complete event");
                return;
            }
            
            const panels = Array.from(document.querySelectorAll('.chat-panel'));
            const currentPanelIndex = panels.findIndex(panel => panel.id === e.detail.panelId);
            console.log("Current panel index:", currentPanelIndex, "Total panels:", panels.length);
            
            // If this is not the last panel, trigger the next one
            if (currentPanelIndex < panels.length - 1) {
                const currentPanel = panels[currentPanelIndex];
                const nextPanel = panels[currentPanelIndex + 1];
                console.log("Next panel id:", nextPanel.id);
                
                // Get all messages from the current panel
                const messages = Array.from(currentPanel.querySelectorAll('.message'));
                
                // Extract the entire conversation history with null checks
                let conversationHistory = [];
                messages.forEach(message => {
                    if (!message) return;
                    
                    const isUser = message.classList.contains('user-message');
                    const contentElement = message.querySelector('.message-content');
                    const senderElement = isUser ? null : message.querySelector('.message-sender');
                    
                    // Only add message if we have valid content
                    if (contentElement && contentElement.textContent) {
                    conversationHistory.push({
                        role: isUser ? "user" : "assistant",
                            sender: isUser ? "User" : (senderElement ? senderElement.textContent : "Assistant"),
                            content: contentElement.textContent
                    });
                    }
                });
                
                console.log(`Extracted ${conversationHistory.length} messages from conversation history`);
                
                // Only proceed if we have messages
                if (conversationHistory.length > 0) {
                    // Format the conversation history in a clearer way for the model
                    let formattedHistory = "# Previous Conversation\n\n";
                    
                    conversationHistory.forEach(msg => {
                        formattedHistory += `## ${msg.sender}:\n${msg.content}\n\n`;
                    });
                    
                    // Add instructions for the next assistant
                    const nextPanelTitle = nextPanel.querySelector('.panel-header h5');
                    const nextPanelRole = nextPanelTitle ? nextPanelTitle.textContent : "Assistant";
                    
                    formattedHistory += `# Instructions\n\nYou are a ${nextPanelRole}. Continue the conversation based on the previous context.\n`;
                    formattedHistory += `You should build on what the previous assistant has said, but bring your own expertise and perspective.\n`;
                    formattedHistory += `Respond directly to the user's last message, taking into account the previous responses.\n\n`;
                    formattedHistory += `# Your Response\n`;
                    
                    console.log("Created formatted prompt for next panel with clear structure");
                    
                    // Set the prompt in the next panel
                    const nextTextarea = nextPanel.querySelector('.prompt-input');
                    if (nextTextarea) {
                        nextTextarea.value = formattedHistory;
                        
                        // Auto-adjust height with maximum limit of 2 lines (approx 70px)
                        nextTextarea.style.height = 'auto';
                        const maxHeight = 70; // Maximum height in pixels (approx 2 lines)
                        
                        // If content height exceeds max height, set to max and enable scrolling
                        if (nextTextarea.scrollHeight > maxHeight) {
                            nextTextarea.style.height = maxHeight + 'px';
                            nextTextarea.style.overflowY = 'auto';
                        } else {
                            nextTextarea.style.height = nextTextarea.scrollHeight + 'px';
                            nextTextarea.style.overflowY = 'hidden';
                        }
                        
                        // Ensure model is selected before sending
                        const nextModelSelect = nextPanel.querySelector('.model-select');
                        if (nextModelSelect && (!nextModelSelect.value || nextModelSelect.value === "")) {
                            console.warn("No model selected in next panel, selecting first available model");
                            if (window.availableModels && window.availableModels.length > 0) {
                                nextModelSelect.value = window.availableModels[0].id;
                            } else {
                                console.error("No models available to select");
                                return;
                            }
                        }
                        
                        // Scroll to the next panel to make it visible
                        nextPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        
                        // Simulate click on send button after a delay to ensure everything is ready
                        console.log("Will click send button in next panel after delay");
                        setTimeout(() => {
                            const sendButton = nextPanel.querySelector('.send-button');
                            if (sendButton && !sendButton.disabled) {
                                console.log("Clicking send button in panel:", nextPanel.id);
                                sendButton.click();
                            } else {
                                console.error("Send button not available or disabled in panel:", nextPanel.id);
                            }
                        }, 1000);
                    } else {
                        console.error("Could not find textarea in next panel:", nextPanel.id);
                    }
                } else {
                    console.error("No conversation history found in panel:", currentPanel.id);
                }
            } else {
                console.log("This is the last panel, no next panel to trigger");
            }
        }
        
        // Function to fetch available models with retries
        function fetchModels(retryCount = 0, maxRetries = 3) {
            console.log(`Fetching models (attempt ${retryCount + 1}/${maxRetries + 1})...`);
            
            // Store current selections before updating
            const currentSelections = {};
            document.querySelectorAll('.model-select').forEach(select => {
                currentSelections[select.closest('.chat-panel').id] = select.value;
            });
            
            // Add loading indicator to the model selects
            document.querySelectorAll('.model-select').forEach(select => {
                select.innerHTML = '<option value="">Loading models...</option>';
            });
            
            fetch('/models', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ server_url: server_url })
            })
            .then(response => {
                console.log("Models API response status:", response.status);
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Models data received:", data);
                if (data.models && data.models.length > 0) {
                    // Store models globally
                    window.availableModels = data.models;
                    console.log("Available models:", window.availableModels);
                    
                    // Populate all model selects while preserving selections
                    document.querySelectorAll('.model-select').forEach(select => {
                        const panelId = select.closest('.chat-panel').id;
                        const previousSelection = currentSelections[panelId];
                        populateModelSelect(select, previousSelection);
                    });
                    
                    // Update upload button visibility for all panels
                    document.querySelectorAll('.chat-panel').forEach(panel => {
                        const uploadBtn = panel.querySelector('.upload-btn');
                        if (uploadBtn) {
                            uploadBtn.style.display = 'inline-flex';
                        }
                    });
                } else {
                    throw new Error('No models found in response');
                }
            })
            .catch(error => {
                console.error('Error fetching models:', error);
                
                // If we haven't exceeded max retries, try again after a delay
                if (retryCount < maxRetries) {
                    console.log(`Retrying in ${(retryCount + 1) * 2} seconds...`);
                    setTimeout(() => {
                        fetchModels(retryCount + 1, maxRetries);
                    }, (retryCount + 1) * 2000); // Exponential backoff
                } else {
                    console.error('Max retries exceeded');
                document.querySelectorAll('.model-select').forEach(select => {
                        const panelId = select.closest('.chat-panel').id;
                        const previousSelection = currentSelections[panelId];
                    select.innerHTML = '<option value="">Error loading models</option>';
                    // Add a second option with the error message
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = error.message;
                    option.disabled = true;
                    select.appendChild(option);
                        
                        // Try to restore previous selection if it exists in the error state
                        if (previousSelection) {
                            const restoreOption = document.createElement('option');
                            restoreOption.value = previousSelection;
                            restoreOption.textContent = previousSelection;
                            select.appendChild(restoreOption);
                            select.value = previousSelection;
                        }
                    });
                }
            });
        }

        // Function to populate model select
        function populateModelSelect(select, selectedModel = "") {
            console.log("Populating model select:", select, "with selected model:", selectedModel);
            
            // Clear existing options except the placeholder
            Array.from(select.options).forEach((option, index) => {
                if (index !== 0) option.remove();
            });
            
            // Set initial option
            select.options[0].textContent = "Select Model";
            
            // If we have models, add them
            if (window.availableModels && window.availableModels.length > 0) {
                console.log(`Adding ${window.availableModels.length} models to select`);
                window.availableModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    // If this is the model we want to select, set it as selected
                    if (model.id === selectedModel) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } else {
                console.warn("No models available to populate select");
            }
        }

        // Function to open summary modal
        function openSummaryModal() {
            console.log("Opening summary modal");
            
            // Get the modal element
            const modalElement = document.getElementById('summaryModal');
            if (!modalElement) {
                console.error('Summary modal element not found');
                return;
            }
            
            // Populate the model select dropdown
            populateSummaryModelSelect();
            
            // Show modal
            const modal = new bootstrap.Modal(modalElement);
            modal.show();
            
            // Add click event listener to the generate button
            const generateBtn = document.getElementById('generateSummaryBtn');
            if (!generateBtn) {
                console.error('Generate summary button not found');
                return;
            }
            
            // Remove any existing click handlers
            generateBtn.replaceWith(generateBtn.cloneNode(true));
            
            // Get the fresh reference after replacement
            const freshGenerateBtn = document.getElementById('generateSummaryBtn');
            freshGenerateBtn.onclick = function() {
                console.log("Generate Summary button clicked from modal");
                generateSummary();
            };
        }
        
        // Function to populate summary model select
        function populateSummaryModelSelect() {
            const select = document.getElementById('summaryModel');
            if (!select) {
                console.error('Summary model select element not found');
                return;
            }
            
            // Clear all existing options
            select.innerHTML = '';
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select Model';
            select.appendChild(defaultOption);
            
            // If we have models, add them
            if (window.availableModels && window.availableModels.length > 0) {
                console.log(`Adding ${window.availableModels.length} models to summary select`);
                window.availableModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    select.appendChild(option);
                });
                
                // Select the first model by default
                if (select.options.length > 1) {
                    select.selectedIndex = 1;
                }
            } else {
                console.warn("No models available for summary generation");
                const noModelsOption = document.createElement('option');
                noModelsOption.value = '';
                noModelsOption.textContent = 'No models available';
                noModelsOption.disabled = true;
                select.appendChild(noModelsOption);
                
                const checkConnectionOption = document.createElement('option');
                checkConnectionOption.value = '';
                checkConnectionOption.textContent = 'Check server connection';
                checkConnectionOption.disabled = true;
                select.appendChild(checkConnectionOption);
            }
        }
        
        // Function to generate summary
        function generateSummary() {
            const selectedModel = document.getElementById('summaryModel').value;
            const summaryType = document.getElementById('summaryType').value;
            
            if (!selectedModel) {
                alert('Please select a model for summarization');
                return;
            }
            
            // Show spinner and hide previous result
            document.getElementById('summarySpinner').style.display = 'block';
            document.getElementById('summaryResult').style.display = 'none';
            
            // Get all panels
            const allPanels = Array.from(document.querySelectorAll('.chat-panel'));
            
            // Collect all messages with timestamps and panel info
            const allMessages = [];
            
            allPanels.forEach((panel, panelIndex) => {
                const panelRole = panel.querySelector('.role-select').value;
                const panelPosture = panel.querySelector('.posture-select').value;
                const panelTitle = `${panelPosture} ${panelRole}`;
                
                // Get all messages from this panel
                const messages = Array.from(panel.querySelectorAll('.message'));
                messages.forEach((message, messageIndex) => {
                    const isUser = message.classList.contains('user-message');
                    const content = message.querySelector('.message-content').textContent;
                    const timestamp = new Date().toLocaleString(); // In a real app, you'd store actual timestamps
                    
                    allMessages.push({
                        panel: panelIndex + 1,
                        panelTitle: panelTitle,
                        messageIndex: messageIndex + 1,
                        role: isUser ? 'user' : 'assistant',
                        sender: isUser ? 'User' : panelTitle,
                        content: content,
                        timestamp: timestamp,
                        type: isUser ? 'question' : 'response'
                    });
                });
            });
            
            if (allMessages.length === 0) {
                alert('No messages found to summarize');
                document.getElementById('summarySpinner').style.display = 'none';
                return;
            }
            
            // Format the conversation history for the summary
            const formattedHistory = allMessages.map(msg => {
                if (msg.type === 'question') {
                    return `Question (${msg.timestamp}):\n${msg.content}`;
                } else {
                    return `Response from ${msg.panelTitle} (${msg.timestamp}):\n${msg.content}`;
                }
            }).join('\n\n');
            
            console.log('Generating summary with:', {
                model: selectedModel,
                summaryType: summaryType,
                messageCount: allMessages.length
            });
            
            // Send to server for summarization
            fetch('/summarize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    conversation: allMessages,
                    model: selectedModel,
                    summaryType: summaryType,
                    server_url: server_url
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.message || `Server returned ${response.status}: ${response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('Summary received:', data);
                // Hide spinner
                document.getElementById('summarySpinner').style.display = 'none';
                
                // Create container for the summary
                const summaryDiv = document.createElement('div');
                
                if (summaryType === 'whatsapp') {
                    // WhatsApp style formatting
                    summaryDiv.className = 'whatsapp-summary';
                    
                    // Add title and timestamp
                    const title = document.createElement('div');
                    title.className = 'title';
                    title.textContent = 'Conversation Summary';
                    summaryDiv.appendChild(title);
                    
                    const timestamp = document.createElement('div');
                    timestamp.className = 'timestamp';
                    timestamp.textContent = new Date().toLocaleString();
                    summaryDiv.appendChild(timestamp);
                    
                    // Add interaction count
                    const stats = document.createElement('div');
                    stats.className = 'section';
                    stats.innerHTML = `
                        <div class="item">ðŸ’¬ Total Interactions: ${allMessages.length}</div>
                        <div class="item">ðŸ‘¥ Participants: ${new Set(allMessages.map(m => m.panelTitle)).size + 1}</div>
                    `;
                    summaryDiv.appendChild(stats);
                    
                    // Add the summary content with WhatsApp formatting
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'section';
                    
                    // Format the summary text with emojis and WhatsApp styling
                    const formattedSummary = data.summary
                        .split('\n')
                        .map(line => {
                            if (!line.trim()) return '';
                            
                            if (line.match(/^[A-Z][\w\s]+:/)) {
                                return `<div class="section-title">${line}</div>`;
                            }
                            
                            if (line.trim().startsWith('-') || line.trim().startsWith('â€¢')) {
                                return `<div class="item">${line.replace(/^[-â€¢]/, 'ðŸ“Œ')}</div>`;
                            }
                            
                            if (line.includes(':')) {
                                return `<div class="item">${line}</div>`;
                            }
                            
                            return `<div class="item">${line}</div>`;
                        })
                        .filter(line => line)
                        .join('');
                    
                    contentDiv.innerHTML = formattedSummary;
                    summaryDiv.appendChild(contentDiv);
                } else {
                    // Regular text formatting for other summary types
                    summaryDiv.className = 'text-summary';
                    
                    // Add title and metadata
                    const title = document.createElement('div');
                    title.className = 'summary-title';
                    title.textContent = summaryType.charAt(0).toUpperCase() + summaryType.slice(1) + ' Summary';
                    summaryDiv.appendChild(title);
                    
                    const metadata = document.createElement('div');
                    metadata.className = 'summary-metadata';
                    metadata.innerHTML = `
                        <div>Generated: ${new Date().toLocaleString()}</div>
                        <div>Total Interactions: ${allMessages.length}</div>
                        <div>Participants: ${new Set(allMessages.map(m => m.panelTitle)).size + 1}</div>
                    `;
                    summaryDiv.appendChild(metadata);
                    
                    // Add content with appropriate formatting
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'summary-content';
                    
                    // Format based on summary type
                    const lines = data.summary.split('\n');
                    const formattedLines = lines.map(line => {
                        if (!line.trim()) return '';
                        
                        if (summaryType === 'bullet' && (line.trim().startsWith('-') || line.trim().startsWith('â€¢'))) {
                            return `<div class="bullet-point">${line}</div>`;
                        }
                        
                        if (line.match(/^[A-Z][\w\s]+:/)) {
                            return `<div class="section-header">${line}</div>`;
                        }
                        
                        return `<div class="text-line">${line}</div>`;
                    }).filter(line => line);
                    
                    contentDiv.innerHTML = formattedLines.join('');
                    summaryDiv.appendChild(contentDiv);
                }
                
                // Display the summary
                document.getElementById('summaryResult').style.display = 'block';
                const summaryContent = document.getElementById('summaryContent');
                summaryContent.innerHTML = '';
                summaryContent.appendChild(summaryDiv);
                
                // Setup copy button
                const copyBtn = document.getElementById('copySummaryBtn');
                copyBtn.onclick = function() {
                    navigator.clipboard.writeText(summaryDiv.innerText)
                        .then(() => {
                            this.innerHTML = '<i class="bi bi-check"></i> Copied';
                            setTimeout(() => {
                                this.innerHTML = '<i class="bi bi-clipboard"></i> Copy';
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Failed to copy summary:', err);
                            alert('Failed to copy summary to clipboard');
                        });
                };
            })
            .catch(error => {
                console.error('Error generating summary:', error);
                document.getElementById('summarySpinner').style.display = 'none';
                alert('Error generating summary: ' + error.message);
            });
        }
        
        // Function to export conversations (kept for reference/future use)
        function exportConversations() {
            const conversations = [];
            
            // For each panel, gather the conversation
            document.querySelectorAll('.chat-panel').forEach(panel => {
                const panelId = panel.id;
                const modelName = panel.querySelector('.model-select').value || 'Unknown Model';
                const messages = [];
                
                // Get all messages
                panel.querySelectorAll('.message').forEach(message => {
                    const isUser = message.classList.contains('user-message');
                    const content = message.querySelector('.message-content').textContent;
                    messages.push({
                        role: isUser ? 'user' : 'assistant',
                        content: content
                    });
                });

                conversations.push({
                    panel: panelId,
                    model: modelName,
                    messages: messages
                });
            });
            
            // Create a blob and download
            const blob = new Blob([JSON.stringify(conversations, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cochat-export-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function createMessageWithCopy(content, className) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${className}`;
            
            // Check if the content contains an image or PDF reference
            const imageMatch = content.match(/\[Image:([^\]]+)\]/);
            const pdfMatch = content.match(/\[PDF:([^\]]+)\]/);
            
            if (imageMatch) {
                const imageId = imageMatch[1];
                const imageUrl = `/file/${imageId}`;
                
                // Create message content with image
                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${content.replace(/\[Image:[^\]]+\]/, `<img src="${imageUrl}" alt="Uploaded image" class="chat-image" loading="lazy">`)}
                    </div>
                    <button class="copy-button" onclick="copyMessage(this)">
                        <i class="bi bi-clipboard"></i>
                    </button>
                `;
            } else if (pdfMatch) {
                const pdfId = pdfMatch[1];
                const pdfUrl = `/file/${pdfId}`;
                
                // Create message content with PDF content
                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${content.replace(/\[PDF:[^\]]+\]/, `
                            <div class="pdf-content">
                                <div class="pdf-header">
                                    <i class="bi bi-file-pdf"></i>
                                    <span>PDF Content</span>
                                </div>
                                <div class="pdf-text" id="pdf-text-${pdfId}">Loading PDF content...</div>
                            </div>
                        `)}
                    </div>
                    <button class="copy-button" onclick="copyMessage(this)">
                        <i class="bi bi-clipboard"></i>
                    </button>
                `;
                
                // Fetch and display PDF content
                fetch(pdfUrl)
                    .then(response => response.text())
                    .then(text => {
                        const pdfText = document.getElementById(`pdf-text-${pdfId}`);
                        if (pdfText) {
                            pdfText.innerHTML = text.replace(/\n/g, '<br>');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading PDF content:', error);
                        const pdfText = document.getElementById(`pdf-text-${pdfId}`);
                        if (pdfText) {
                            pdfText.innerHTML = 'Error loading PDF content';
                        }
                    });
                        } else {
                // Create regular message content
                messageDiv.innerHTML = `
                    <div class="message-content">${content}</div>
                    <button class="copy-button" onclick="copyMessage(this)">
                        <i class="bi bi-clipboard"></i>
                    </button>
                `;
            }
            
            return messageDiv;
        }

        function detectModelCapabilities(modelId) {
            if (!modelId) return { vision: false };
            
            const visionPatterns = [
                'vl',           // Qwen VL models
                'vision',       // Generic vision models
                'visual',       // Visual models
                'multimodal',   // Multimodal models
                'image',        // Image-capable models
                'ocr'          // OCR models like olmocr
            ];
            
            modelId = modelId.toLowerCase();
            const hasVisionCapability = visionPatterns.some(pattern => modelId.includes(pattern));
            
            return {
                vision: hasVisionCapability
            };
        }

        function updateUploadButtonVisibility(panel) {
            const modelSelect = panel.querySelector('.model-select');
            const uploadBtn = panel.querySelector('.upload-btn');
            const fileInput = panel.querySelector('.file-input');
            
            if (!modelSelect || !uploadBtn || !fileInput) return;
            
            const selectedModel = modelSelect.value;
            const capabilities = detectModelCapabilities(selectedModel);
            
            // Show upload button if model is selected
            uploadBtn.style.display = selectedModel ? 'inline-flex' : 'none';
            
            // Update file input accept attribute based on capabilities
            fileInput.accept = capabilities.vision ? 'image/*' : '*/*';
            
            // Update button tooltip
            uploadBtn.title = capabilities.vision ? 'Upload Image' : 'Upload File';
        }

        // Add styles for PDF content
        const style = document.createElement('style');
        style.textContent = `
            .pdf-content {
                margin: 10px 0;
                padding: 15px;
                background: #f8f9fa;
                border-radius: 8px;
                border: 1px solid #dee2e6;
            }
            
            .pdf-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 10px;
                color: #dc3545;
                font-weight: 500;
            }
            
            .pdf-header i {
                font-size: 1.2em;
            }
            
            .pdf-text {
                white-space: pre-wrap;
                font-family: monospace;
                font-size: 0.9em;
                line-height: 1.5;
                color: #212529;
            }
            
            .chat-image {
                max-width: 300px;
                max-height: 300px;
                border-radius: 8px;
                margin: 10px 0;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                display: block;
            }
            
            .message-content {
                word-wrap: break-word;
                white-space: pre-wrap;
            }
            
            .message-content img {
                max-width: 100%;
                height: auto;
            }
        `;
        document.head.appendChild(style);

        // Function to setup chat mode handlers
        function setupChatModeHandlers() {
            const modeDropdown = document.querySelector('.dropdown-menu');
            const currentModeSpan = document.getElementById('currentMode');
            const processingModeSelect = document.getElementById('processingMode');
            
            if (modeDropdown && currentModeSpan && processingModeSelect) {
                modeDropdown.addEventListener('click', function(e) {
                    if (e.target.classList.contains('dropdown-item')) {
                        e.preventDefault();
                        const mode = e.target.dataset.mode;
                        currentModeSpan.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
                        processingModeSelect.value = mode;
                        
                        // Setup sequential monitoring if needed
                        if (mode === 'sequential') {
                            setupSequentialMonitoring();
                        }
                    }
                });
            }
        }

        // Add styles for upload progress
        const uploadProgressStyle = document.createElement('style');
        uploadProgressStyle.textContent = `
            .upload-progress {
                position: fixed;
                top: 20px;
                right: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 1000;
                min-width: 300px;
            }
            
            .progress-bar {
                width: 100%;
                height: 4px;
                background: #e9ecef;
                border-radius: 2px;
                overflow: hidden;
                margin-bottom: 8px;
            }
            
            .progress-fill {
                width: 0%;
                height: 100%;
                background: #0d6efd;
                transition: width 0.3s ease;
            }
            
            .progress-text {
                font-size: 0.9em;
                color: #6c757d;
                text-align: center;
            }
        `;
        document.head.appendChild(uploadProgressStyle);

        // Function to create response header
        function createResponseHeader(type) {
            const header = document.createElement('div');
            header.className = 'response-header';
            
            const icon = document.createElement('div');
            icon.className = 'response-header-icon';
            
            const text = document.createElement('div');
            text.className = 'response-header-text thinking-dots';
            
            switch (type.toLowerCase()) {
                case 'think':
                case 'thinking':
                    text.textContent = 'Thinking';
                    icon.innerHTML = '<i class="bi bi-brain"></i>';
                    break;
                case 'analysis':
                case 'analyzing':
                    text.textContent = 'Analyzing';
                    icon.innerHTML = '<i class="bi bi-graph-up"></i>';
                    break;
                case 'insight':
                case 'insights':
                    text.textContent = 'Generating insights';
                    icon.innerHTML = '<i class="bi bi-lightbulb"></i>';
                    break;
                case 'response':
                    text.textContent = 'Responding';
                    icon.innerHTML = '<i class="bi bi-chat-dots"></i>';
                    break;
                case 'answer':
                    text.textContent = 'Answering';
                    icon.innerHTML = '<i class="bi bi-check2-circle"></i>';
                    break;
                default:
                    text.textContent = 'Processing';
                    icon.innerHTML = '<i class="bi bi-cpu"></i>';
            }
            
            header.appendChild(icon);
            header.appendChild(text);
            return header;
        }

        // Function to handle stream response
        async function handleStreamResponse(response, chatWindow, panel) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let assistantMessage = null;
            let assistantResponse = '';
            let currentHeader = null;
            let currentResponseType = '';
            
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') continue;
                            
                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.choices && parsed.choices[0]) {
                                    const content = parsed.choices[0].delta.content || '';
                                    assistantResponse += content;
                                    
                                    // Check for response type tags
                                    const thinkMatch = content.match(/<(think|analysis|insight|response|answer)>/i);
                                    if (thinkMatch) {
                                        const type = thinkMatch[1];
                                        if (type !== currentResponseType) {
                                            currentResponseType = type;
                                            // Remove previous header if exists
                                            if (currentHeader) {
                                                currentHeader.remove();
                                            }
                                            // Create and add new header
                                            currentHeader = createResponseHeader(type);
                                            if (assistantMessage) {
                                                assistantMessage.insertBefore(currentHeader, assistantMessage.querySelector('.message-content'));
                                            }
                                        }
                                    }
                                    
                                    // Create or update the assistant message
                                    if (!assistantMessage) {
                                        assistantMessage = createMessageWithCopy(assistantResponse, 'assistant-message');
                                        assistantMessage.dataset.panelId = panel.id;
                                        assistantMessage.className = 'message assistant-message response-type-container';
                                        chatWindow.appendChild(assistantMessage);
                                    } else {
                                        assistantMessage.querySelector('.message-content').textContent = assistantResponse;
                                    }
                                    
                                    chatWindow.scrollTop = chatWindow.scrollHeight;
                                    
                                    // Handle sequential mode complete response
                                    if (parsed.complete_response && parsed.sequential_mode) {
                                        const processingMode = document.getElementById('processingMode').value;
                                        if (processingMode === 'sequential') {
                                            // Get all panels
                                            const panels = Array.from(document.querySelectorAll('.chat-panel'));
                                            const currentIndex = panels.indexOf(panel);
                                            
                                            // If there's a next panel, send the complete response to it
                                            if (currentIndex < panels.length - 1) {
                                                const nextPanel = panels[currentIndex + 1];
                                                const nextPanelInput = nextPanel.querySelector('.prompt-input');
                                                if (nextPanelInput) {
                                                    // Set the complete response in the next panel's input
                                                    nextPanelInput.value = assistantResponse;
                                                    
                                                    // Get the send button of the next panel
                                                    const nextPanelSendButton = nextPanel.querySelector('.send-button');
                                                    if (nextPanelSendButton) {
                                                        // Trigger the send button click after a short delay
                                                        setTimeout(() => {
                                                            nextPanelSendButton.click();
                                                        }, 500);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Error parsing streaming data:', e);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error in stream:', error);
                const errorMessage = createMessageWithCopy('Error: ' + error.message, 'error-message');
                chatWindow.appendChild(errorMessage);
            } finally {
                // Remove the header when done
                if (currentHeader) {
                    currentHeader.remove();
                }
            }
        }

        function clearChat(button) {
            const panel = button.closest('.chat-panel');
            const chatWindow = panel.querySelector('.chat-window');
            chatWindow.innerHTML = '';
        }

        window.isCyclicActive = false;

        // Add Stop Cycle button
        const stopBtn = document.createElement('button');
        stopBtn.id = 'stopCyclicBtn';
        stopBtn.textContent = 'Stop Cycle';
        stopBtn.style.display = 'none';
        stopBtn.style.position = 'fixed';
        stopBtn.style.top = '10px';
        stopBtn.style.right = '10px';
        stopBtn.style.zIndex = '1000';
        document.body.appendChild(stopBtn);
        function showStopBtn(show) {
          stopBtn.style.display = show ? 'block' : 'none';
        }
        stopBtn.onclick = () => {
          window.isCyclicActive = false;
          showStopBtn(false);
        };

        // Update mode selection to handle cyclic
        const modeDropdownItems = document.querySelectorAll('.dropdown-item[data-mode]');
        modeDropdownItems.forEach(item => {
          item.addEventListener('click', function(e) {
            const mode = this.getAttribute('data-mode');
            window.isCyclicActive = (mode === 'cyclic');
            showStopBtn(window.isCyclicActive);
            // ...existing mode change logic...
          });
        });

        // Core cycling logic
        function handlePanelResponse(panelIndex, response) {
          if (!window.isCyclicActive) return;
          const panels = Array.from(document.querySelectorAll('.chat-panel'));
          const nextIndex = (panelIndex + 1) % panels.length;
          const nextPanel = panels[nextIndex];
          const textarea = nextPanel.querySelector('.prompt-input');
          textarea.value = response;
          setTimeout(() => {
            if (window.isCyclicActive) {
              const sendButton = nextPanel.querySelector('.send-button');
              sendButton.click();
            }
          }, 1000);
        }

        // Patch sendMessage to support cyclic mode
        const originalSendMessage = window.sendMessage || sendMessage;
        window.sendMessage = async function(button) {
          const panel = button.closest('.chat-panel');
          const panels = Array.from(document.querySelectorAll('.chat-panel'));
          const panelIndex = panels.indexOf(panel);
          const textarea = panel.querySelector('.prompt-input');
          const userInitiated = button.classList.contains('send-button') && !window.isCyclicActive;
          await originalSendMessage.apply(this, arguments);
          // After the assistant responds, if cyclic mode is active and this was not a user-initiated send, cycle to next panel
          if (window.isCyclicActive && !userInitiated) {
            // Find the last assistant message in this panel
            const chatWindow = panel.querySelector('.chat-window');
            const messages = Array.from(chatWindow.querySelectorAll('.assistant-message .message-content'));
            if (messages.length > 0) {
              const lastResponse = messages[messages.length - 1].textContent;
              handlePanelResponse(panelIndex, lastResponse);
            }
          }
        };
    </script>
</body>
</html>
