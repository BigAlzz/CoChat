<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoChat</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <div class="app-header">
        <div class="app-logo">CoChat</div>
        <div class="header-controls">
            <button class="header-btn" id="muteButton"><i class="bi bi-volume-up"></i></button>
            <button class="header-btn" id="exportButton" title="Generate Summary"><i class="bi bi-card-text"></i></button>
            <div class="position-relative dropdown">
                <button class="header-btn d-flex align-items-center gap-2" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                    <span id="currentMode">Individual</span>
                    <i class="bi bi-chevron-down"></i>
                </button>
                <ul class="dropdown-menu dropdown-menu-dark">
                    <li><a class="dropdown-item" href="#" data-mode="individual">Individual</a></li>
                    <li><a class="dropdown-item" href="#" data-mode="sequential">Sequential</a></li>
                    <li><a class="dropdown-item" href="#" data-mode="parallel">Parallel</a></li>
                </ul>
                </div>
            <button class="add-panel-btn" id="addAssistant"><i class="bi bi-plus"></i> Add Panel</button>
            <button class="header-btn" id="settingsButton" onclick="openSettings()"><i class="bi bi-gear"></i></button>
            </div>
        </div>

    <!-- Hidden select to maintain compatibility with existing JavaScript -->
    <select id="processingMode" style="display: none;">
        <option value="individual" selected>Individual</option>
        <option value="sequential">Sequential</option>
        <option value="parallel">Parallel</option>
    </select>

        <div id="assistantsContainer">
            <!-- Template for assistant panel -->
            <div class="chat-panel" id="assistant-1">
                <div class="panel-header">
                <h5>professional researcher</h5>
                <button class="close-button" onclick="removeAssistant('assistant-1')"><i class="bi bi-x-lg"></i></button>
                </div>
                <div class="model-config">
                <div class="d-flex align-items-center justify-content-between px-3 py-2">
                            <select class="model-select cyber-pill" onchange="handleModelChange(this)">
                            <option value="">Select Model</option>
                        </select>
                    <div class="form-check form-switch ms-3">
                        <input class="form-check-input stream-toggle" type="checkbox" id="streamToggle-1" checked>
                        <label class="form-check-label" for="streamToggle-1">Enable Streaming</label>
                        </div>
                    </div>
                </div>
                <div class="chat-window" id="chat-1"></div>
                <div class="panel-controls">
                <div>
                    <textarea class="prompt-input" rows="2" placeholder="Type your message..."></textarea>
                    <div class="d-flex align-items-center gap-2 mt-2">
                        <select class="posture-select" style="max-width: 180px;">
                            <option value="professional">Professional</option>
                            <option value="academic">Academic & Scholarly</option>
                            <option value="analytical">Analytical & Methodical</option>
                            <option value="casual">Casual & Friendly</option>
                            <option value="concise" selected>Concise & Direct</option>
                            <option value="creative">Creative & Imaginative</option>
                        </select>
                        <select class="role-select" style="max-width: 130px;">
                            <option value="researcher">Researcher</option>
                            <option value="analyst">Data Analyst</option>
                            <option value="assistant">General Assistant</option>
                            <option value="coder">Code Assistant</option>
                            <option value="expert">Domain Expert</option>
                            <option value="technical">Technical Expert</option>
                            <option value="writer">Writer</option>
                        </select>
                        <div class="ms-auto d-flex gap-2">
                            <input type="file" class="file-input" accept="*/*" style="display: none;">
                            <button class="btn btn-sm btn-outline-secondary upload-btn" title="Upload File/Image" style="display: none;">
                                <i class="bi bi-upload"></i>
                            </button>
                            <button class="send-button">Send</button>
                            <button class="stop-button" style="display: none;">Stop</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">LM Studio Servers</label>
                        <div id="serverList" class="mb-2">
                            <!-- Server entries will be added here -->
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-primary" onclick="addServerEntry()">
                            <i class="bi bi-plus-circle"></i> Add Server
                        </button>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn header-btn" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn add-panel-btn" onclick="saveSettings()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Summary Modal -->
    <div class="modal fade" id="summaryModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Generate Summary</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="summaryModel" class="form-label">Select Model for Summary</label>
                        <select class="form-select" id="summaryModel">
                            <!-- Models will be populated here -->
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="summaryType" class="form-label">Summary Type</label>
                        <select class="form-select" id="summaryType">
                            <option value="concise">Concise Summary</option>
                            <option value="detailed">Detailed Summary</option>
                            <option value="whatsapp">WhatsApp Style</option>
                            <option value="bullet">Bullet Points</option>
                            <option value="executive">Executive Summary</option>
                        </select>
                    </div>
                    <div id="summarySpinner" class="text-center" style="display: none;">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <div id="summaryResult" style="display: none;">
                        <h5>Summary:</h5>
                        <div id="summaryContent" class="border p-3 rounded bg-light"></div>
                        <button id="copySummaryBtn" class="btn btn-sm btn-outline-primary mt-2">
                            <i class="bi bi-clipboard"></i> Copy
                        </button>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn header-btn" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn add-panel-btn" id="generateSummaryBtn">Generate Summary</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let assistantCount = 1;
        let server_url = localStorage.getItem('lmStudioUrl') || 'http://192.168.50.10:3500';
        
        // Initialize when document is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Document ready, initializing app...");
            
            // Load saved servers from local storage or set default
            const savedServers = JSON.parse(localStorage.getItem('lmStudioServers') || '[]');
            if (savedServers.length === 0) {
                // Save default server if no servers are saved
                localStorage.setItem('lmStudioServers', JSON.stringify([server_url]));
                
                // Save to server immediately
                fetch('/save_settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        lm_url: server_url
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Default settings saved successfully:", data);
                    // Initial fetch of models with retries
                    fetchModels();
                })
                .catch(error => {
                    console.error('Error saving default settings:', error);
                    // Still try to fetch models even if settings save fails
                    fetchModels();
                });
            } else {
                // Use the first saved server as primary
                server_url = savedServers[0];
                // Initial fetch of models with retries
                fetchModels();
            }
            
            // Setup periodic refresh of models every 30 seconds
            setInterval(() => {
                fetchModels();
            }, 30000);
            
            // Setup event listeners for initial panel
            const initialPanel = document.getElementById('assistant-1');
            setupMessageHandlers(initialPanel);
            setupUploadHandlers(initialPanel);
            
            // Make upload button visible by default
            const uploadBtn = initialPanel.querySelector('.upload-btn');
            if (uploadBtn) {
                uploadBtn.style.display = 'inline-flex';
            }

            // Setup chat mode handlers
            setupChatModeHandlers();
            
            // Setup summary button handler
            const exportButton = document.getElementById('exportButton');
            if (exportButton) {
                exportButton.onclick = openSummaryModal;
            }

            // Setup Add Panel button handler
            const addPanelButton = document.getElementById('addAssistant');
            if (addPanelButton) {
                addPanelButton.onclick = addAssistant;
            }
            
            // Rest of your initialization code...
        });
        
        // Function to add a new server entry
        function addServerEntry(url = '') {
            const serverList = document.getElementById('serverList');
            const serverEntry = document.createElement('div');
            serverEntry.className = 'input-group mb-2';
            serverEntry.innerHTML = `
                <input type="text" class="form-control server-url" value="${url}" placeholder="Enter server URL">
                <button class="btn btn-outline-danger" onclick="this.closest('.input-group').remove()">
                    <i class="bi bi-trash"></i>
                </button>
            `;
            serverList.appendChild(serverEntry);
        }
        
        // Function to open settings modal
        function openSettings() {
            // Clear existing server entries
            const serverList = document.getElementById('serverList');
            serverList.innerHTML = '';
            
            // Load saved servers from local storage
            const savedServers = JSON.parse(localStorage.getItem('lmStudioServers') || '[]');
            if (savedServers.length === 0) {
                // Add default server if no servers are saved
                addServerEntry('http://172.17.64.1:3500');
            } else {
                savedServers.forEach(server => addServerEntry(server));
            }
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('settingsModal'));
            modal.show();
        }
        
        // Function to save settings
        function saveSettings() {
            // Save server URLs
            const serverUrls = Array.from(document.querySelectorAll('.server-url'))
                .map(input => input.value.trim())
                .filter(url => url !== '');
            
            localStorage.setItem('lmStudioServers', JSON.stringify(serverUrls));
            server_url = serverUrls[0]; // Use first server as primary
            
            // Save to server
            fetch('/save_settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    lm_url: server_url
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.message || 'Failed to save settings');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log("Settings saved successfully:", data);
                showToast('Settings saved successfully', 'success');
                
                // Reload models with the new URL
                fetchModels();
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
                modal.hide();
            })
            .catch(error => {
                console.error('Error saving settings:', error);
                showToast('Failed to save settings: ' + error.message, 'error');
            });
        }
        
        // Function to check if a model supports vision capabilities
        function isVisionModel(model) {
            if (!model || typeof model !== 'object') return false;
            
            // Check model ID and capabilities
            const modelId = model.id.toLowerCase();
            const visionKeywords = ['vision', 'vl', 'visual', 'multimodal', 'llava', 'qwen-vl', 'bakllava', 'obsidian'];
            return visionKeywords.some(keyword => modelId.includes(keyword));
        }

        // Function to update upload controls visibility
        function updateUploadControls() {
            document.querySelectorAll('.chat-panel').forEach(panel => {
                const modelSelect = panel.querySelector('.model-select');
                const selectedModel = modelSelect.value;
                const model = window.availableModels?.find(m => m.id === selectedModel);
                
                const uploadBtn = panel.querySelector('.upload-btn');
                const uploadInput = panel.querySelector('.file-input');
                
                if (uploadBtn && uploadInput) {
                    // Always show upload button, we'll handle capability checks when files are selected
                    uploadBtn.style.display = 'block';
                    
                    // Update button tooltip based on model capabilities
                    if (model && isVisionModel(model)) {
                        uploadBtn.title = 'Upload File/Image (Vision Capable)';
                        uploadInput.accept = '*/*';  // Accept all files
                    } else {
                        uploadBtn.title = 'Upload File (No Vision Support)';
                        uploadInput.accept = '*/*';  // Accept all files
                    }
                }
            });
        }

        // Function to handle model change
        function handleModelChange(select) {
            const panel = select.closest('.chat-panel');
            const selectedModel = select.value;
            const model = window.availableModels?.find(m => m.id === selectedModel);
            
            // Update upload buttons visibility based on model capabilities
            if (model) {
                const uploadBtn = panel.querySelector('.upload-btn');
                const uploadInput = panel.querySelector('.upload-input');
                const enableFileUpload = localStorage.getItem('enableFileUpload') === 'true';
                const enableImageUpload = localStorage.getItem('enableImageUpload') === 'true';
                
                if (uploadBtn) {
                    const showUpload = enableFileUpload || (enableImageUpload && isVisionModel(model));
                    uploadBtn.style.display = showUpload ? 'block' : 'none';
                    
                    // Update accept attribute based on capabilities
                    if (uploadInput) {
                        if (enableFileUpload && enableImageUpload && model && isVisionModel(model)) {
                            uploadInput.accept = '*/*';
                        } else if (enableImageUpload && model && isVisionModel(model)) {
                            uploadInput.accept = 'image/*';
                        } else if (enableFileUpload) {
                            uploadInput.accept = '*/*';
                        }
                    }
                }
            }
        }
        
        // Function to create a new assistant panel
        function addAssistant() {
            // Find the active panel (panel with focus or last interacted panel)
            let activePanel = document.activeElement ? 
                document.activeElement.closest('.chat-panel') : null;
            
            if (!activePanel) {
                // Try to find a panel with a visible stop button (currently processing)
                const activePanels = Array.from(document.querySelectorAll('.chat-panel')).filter(panel => 
                    panel.querySelector('.stop-button').style.display !== 'none'
                );
                
                if (activePanels.length > 0) {
                    activePanel = activePanels[0];
                } else {
                    // Fallback to the first panel
                    activePanel = document.querySelector('.chat-panel');
                }
            }
            
            // Get settings from active panel
            let activeSettings = {
                model: "",
                role: "researcher",
                posture: "professional",
                streamEnabled: false
            };
            
            if (activePanel) {
                const modelSelect = activePanel.querySelector('.model-select');
                const roleSelect = activePanel.querySelector('.role-select');
                const postureSelect = activePanel.querySelector('.posture-select');
                const streamToggle = activePanel.querySelector('.stream-toggle');
                
                activeSettings = {
                    model: modelSelect ? modelSelect.value : "",
                    role: roleSelect ? roleSelect.value : "researcher",
                    posture: postureSelect ? postureSelect.value : "professional",
                    streamEnabled: streamToggle ? streamToggle.checked : false
                };
                
                console.log("Cloning settings from active panel:", activeSettings);
            }
            
            assistantCount++;
            const newAssistant = createAssistantPanel(assistantCount, activeSettings);
            document.getElementById('assistantsContainer').appendChild(newAssistant);
            setupMessageHandlers(newAssistant);
            populateModelSelect(newAssistant.querySelector('.model-select'), activeSettings.model);
        }
        
        // Function to create a new assistant panel
        function createAssistantPanel(id, settings = null) {
            const panel = document.createElement('div');
            panel.className = 'chat-panel';
            panel.id = `assistant-${id}`;
            
            // Use provided settings or defaults
            const defaultSettings = {
                model: "",
                role: "researcher",
                posture: "professional",
                streamEnabled: false
            };
            
            const panelSettings = settings || defaultSettings;
            const { role, posture, streamEnabled } = panelSettings;
            
            panel.innerHTML = `
                <div class="panel-header">
                    <h5>${posture} ${role}</h5>
                    <button class="close-button" onclick="removeAssistant('assistant-${id}')"><i class="bi bi-x-lg"></i></button>
                </div>
                <div class="model-config">
                    <div class="d-flex align-items-center justify-content-between px-3 py-2">
                        <select class="model-select" onchange="handleModelChange(this)">
                            <option value="">Select Model</option>
                        </select>
                        <div class="form-check form-switch ms-3">
                            <input class="form-check-input stream-toggle" type="checkbox" id="streamToggle-${id}" ${streamEnabled ? 'checked' : ''}>
                            <label class="form-check-label" for="streamToggle-${id}">Enable Streaming</label>
                        </div>
                    </div>
                </div>
                <div class="chat-window" id="chat-${id}"></div>
                <div class="panel-controls">
                    <div>
                        <textarea class="prompt-input" rows="2" placeholder="Type your message..."></textarea>
                        <div class="d-flex align-items-center gap-2 mt-2">
                            <select class="posture-select" style="max-width: 180px;">
                                <option value="professional" ${posture === 'professional' ? 'selected' : ''}>Professional</option>
                                <option value="academic" ${posture === 'academic' ? 'selected' : ''}>Academic & Scholarly</option>
                                <option value="analytical" ${posture === 'analytical' ? 'selected' : ''}>Analytical & Methodical</option>
                                <option value="casual" ${posture === 'casual' ? 'selected' : ''}>Casual & Friendly</option>
                                <option value="concise" ${posture === 'concise' ? 'selected' : ''}>Concise & Direct</option>
                                <option value="creative" ${posture === 'creative' ? 'selected' : ''}>Creative & Imaginative</option>
                            </select>
                            <select class="role-select" style="max-width: 130px;">
                                <option value="researcher" ${role === 'researcher' ? 'selected' : ''}>Researcher</option>
                                <option value="analyst" ${role === 'analyst' ? 'selected' : ''}>Data Analyst</option>
                                <option value="assistant" ${role === 'assistant' ? 'selected' : ''}>General Assistant</option>
                                <option value="coder" ${role === 'coder' ? 'selected' : ''}>Code Assistant</option>
                                <option value="expert" ${role === 'expert' ? 'selected' : ''}>Domain Expert</option>
                                <option value="technical" ${role === 'technical' ? 'selected' : ''}>Technical Expert</option>
                                <option value="writer" ${role === 'writer' ? 'selected' : ''}>Writer</option>
                            </select>
                            <div class="ms-auto d-flex gap-2">
                                <input type="file" class="file-input" accept="*/*" style="display: none;">
                                <button class="btn btn-sm btn-outline-secondary upload-btn" title="Upload File/Image" style="display: none;">
                                    <i class="bi bi-upload"></i>
                                </button>
                                <button class="send-button">Send</button>
                                <button class="stop-button" style="display: none;">Stop</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Setup upload handlers
            setupUploadHandlers(panel);
            
            // Update upload controls visibility
            updateUploadButtonVisibility(panel);
            
            return panel;
        }
        
        // Function to setup upload handlers
        function setupUploadHandlers(panel) {
            const uploadBtn = panel.querySelector('.upload-btn');
            const fileInput = panel.querySelector('.file-input');
            
            if (uploadBtn && fileInput) {
                // Make upload button visible
                uploadBtn.style.display = 'inline-flex';
                
                // Remove any existing listeners
                uploadBtn.replaceWith(uploadBtn.cloneNode(true));
                fileInput.replaceWith(fileInput.cloneNode(true));
                
                // Get fresh references
                const newUploadBtn = panel.querySelector('.upload-btn');
                const newFileInput = panel.querySelector('.file-input');
                
                // Add click handler
                newUploadBtn.addEventListener('click', () => {
                    newFileInput.click();
                });
                
                // Add change handler
                newFileInput.addEventListener('change', handleUpload);
            }
        }
        
        // Function to show toast message
        function showToast(message, type = 'error') {
            const toastContainer = document.querySelector('.toast-container') || (() => {
                const container = document.createElement('div');
                container.className = 'toast-container';
                document.body.appendChild(container);
                return container;
            })();

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <i class="bi bi-exclamation-circle"></i>
                <span>${message}</span>
                <span class="close-btn" onclick="this.parentElement.remove()">Ã—</span>
            `;

            toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 5000);
        }

        // Function to handle file/image upload
        function handleUpload(event) {
            const fileInput = event.target;
            const panel = fileInput.closest('.chat-panel');
            const file = fileInput.files[0];
            
            if (!file) return;
            
            // Create FormData and append file
            const formData = new FormData();
            formData.append('file', file);
            
            // Show loading state
            const uploadBtn = panel.querySelector('.upload-btn');
            const originalContent = uploadBtn.innerHTML;
            uploadBtn.innerHTML = '<i class="bi bi-hourglass-split"></i>';
            uploadBtn.disabled = true;
            
            // Upload the file
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Upload failed: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('File uploaded:', data);
                
                // Add file reference to message input
                const messageInput = panel.querySelector('.prompt-input');
                const isImage = file.type.startsWith('image/');
                const fileReference = isImage ? 
                    `[Image: ${data.filename}](${data.url})` : 
                    `[File: ${data.filename}](${data.url})`;
                    
                messageInput.value = messageInput.value ? 
                    `${messageInput.value}\n${fileReference}` : 
                    fileReference;
                
                // Show success message
                showToast(`${isImage ? 'Image' : 'File'} uploaded successfully`, 'success');
            })
            .catch(error => {
                console.error('Error uploading file:', error);
                showToast(error.message || 'Failed to upload file', 'error');
            })
            .finally(() => {
                // Reset upload button
                uploadBtn.innerHTML = originalContent;
                uploadBtn.disabled = false;
                fileInput.value = '';
            });
        }
        
        // Function to remove an assistant panel
        function removeAssistant(assistantId) {
            const panel = document.getElementById(assistantId);
            if (panel) {
                    panel.remove();
                        adjustPanelWidths();
                    }
        }
        
        // Function to adjust panel widths based on number of panels
        function adjustPanelWidths() {
            const container = document.getElementById('assistantsContainer');
            const panels = container.querySelectorAll('.chat-panel');
            
            // If more than 3 panels, set to a percentage with a minimum width
            if (panels.length > 3) {
                const width = Math.max(30, 100 / panels.length);
                panels.forEach(panel => {
                    panel.style.width = `${width}%`;
                    panel.style.flex = '0 0 auto';
                });
            } else {
                panels.forEach(panel => {
                    panel.style.width = '';
                    panel.style.flex = '1';
                });
            }
        }
        
        // Function to set up message handlers
        function setupMessageHandlers(panel) {
            const textarea = panel.querySelector('.prompt-input');
            const sendButton = panel.querySelector('.send-button');
            const roleSelect = panel.querySelector('.role-select');
            const postureSelect = panel.querySelector('.posture-select');
            const panelTitle = panel.querySelector('.panel-header h5');
            
            // Set initial panel title
            updatePanelTitle(panel);
            
            // Add listeners for role and posture changes to update panel title
            roleSelect.addEventListener('change', function() {
                updatePanelTitle(panel);
            });
            
            postureSelect.addEventListener('change', function() {
                updatePanelTitle(panel);
            });
            
            // Enter key handler
            textarea.addEventListener('keydown', function(e) {
                console.log("Key pressed in textarea:", e.key);
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage(sendButton);
                }
            });

            // Send button handler
            sendButton.addEventListener('click', function() {
                console.log("Send button clicked");
                sendMessage(this);
            });
            
            // Auto-resize the textarea
            textarea.addEventListener('input', function() {
                // Keep fixed height and enable scrolling
                this.style.height = '60px';
                this.style.overflowY = 'auto';
            });
        }
        
        // Function to update panel title based on role and posture
        function updatePanelTitle(panel) {
            const roleSelect = panel.querySelector('.role-select');
            const postureSelect = panel.querySelector('.posture-select');
            const panelTitle = panel.querySelector('.panel-header h5');
            
            if (roleSelect && postureSelect && panelTitle) {
                const role = roleSelect.options[roleSelect.selectedIndex].textContent.toLowerCase();
                const posture = postureSelect.options[postureSelect.selectedIndex].textContent.toLowerCase();
                panelTitle.textContent = `${posture} ${role}`;
            }
        }
        
        // Function to handle message sending
        async function sendMessage(button) {
            const panel = button.closest('.chat-panel');
            if (!panel) {
                console.error("Cannot find parent panel for send button");
                return;
            }
            
            const textarea = panel.querySelector('.prompt-input');
            const chatWindow = panel.querySelector('.chat-window');
            const sendButton = panel.querySelector('.send-button');
            const stopButton = panel.querySelector('.stop-button');
            const modelSelect = panel.querySelector('.model-select');
            const roleSelect = panel.querySelector('.role-select');
            const postureSelect = panel.querySelector('.posture-select');
            const streamEnabled = panel.querySelector('.stream-toggle').checked;
            
            const message = textarea.value.trim();
            if (!message) return;
            
            // Check if we can send in sequential mode
            const processingMode = document.getElementById('processingMode').value;
            if (processingMode === 'sequential' && !canSendInSequentialMode(panel)) {
                alert('In sequential mode, you must wait for the previous assistant to finish.');
                return;
            }

            // Clear the input
            textarea.value = '';
            
            // Add the user message to the chat
            const userMessageElement = createMessageWithCopy(message, 'user-message');
            chatWindow.appendChild(userMessageElement);
            chatWindow.scrollTop = chatWindow.scrollHeight;
            
            // Check if the message contains an image
            const hasImage = message.includes('[Image:');
            if (hasImage) {
                // Create and add the analyzing animation
                const analyzingElement = document.createElement('div');
                analyzingElement.className = 'analyzing-container';
                analyzingElement.innerHTML = `
                    <div class="analyzing-text">Analyzing image...</div>
                    <div class="bouncing-balls">
                        <div class="bouncing-ball"></div>
                        <div class="bouncing-ball"></div>
                        <div class="bouncing-ball"></div>
                    </div>
                `;
                chatWindow.appendChild(analyzingElement);
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
            
            // Disable the send button, show stop button
            sendButton.disabled = true;
            stopButton.style.display = 'block';

            // Prepare the data
            const model = modelSelect.value;
            const role = roleSelect.value;
            const posture = postureSelect.value;
            
            // Send the message to the server
            let controller = new AbortController();
            const signal = controller.signal;
            
            // Set up the abort function
            stopButton.onclick = function() {
                controller.abort();
                stopButton.style.display = 'none';
                sendButton.disabled = false;
                
                // Remove analyzing animation if it exists
                const analyzingElement = chatWindow.querySelector('.analyzing-container');
                if (analyzingElement) {
                    analyzingElement.remove();
                }
                
                // Dispatch event to notify that the response is complete
                const event = new CustomEvent('responseComplete', {
                    detail: { panelId: panel.id }
                });
                document.dispatchEvent(event);
            };
            
            console.log('Sending chat request:', {
                model,
                role,
                posture,
                streamEnabled,
                messageLength: message.length
            });
            
            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message,
                        model: model,
                        stream: streamEnabled,
                        temperature: 0.7,
                        max_tokens: 2000,
                        top_p: 0.95,
                        frequency_penalty: 0,
                        presence_penalty: 0,
                        stop: [],
                        mode: processingMode,
                        posture: posture,
                        role: role
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                if (streamEnabled) {
                    // Handle streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantResponse = '';
                    let assistantMessage = null;

                    while (true) {
                        const {value, done} = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') {
                                    break;
                                }
                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.choices && parsed.choices[0]) {
                                        const content = parsed.choices[0].delta.content || '';
                                        assistantResponse += content;
                                        
                                        // Create or update the assistant message
                                        if (!assistantMessage) {
                                            assistantMessage = createMessageWithCopy(assistantResponse, 'assistant-message');
                                            assistantMessage.dataset.panelId = panel.id;
                                            chatWindow.appendChild(assistantMessage);
                                        } else {
                                            assistantMessage.querySelector('.message-content').textContent = assistantResponse;
                                        }
                                        
                                        chatWindow.scrollTop = chatWindow.scrollHeight;
                                    }
                                } catch (e) {
                                    console.error('Error parsing streaming data:', e);
                                }
                            }
                        }
                    }
                } else {
                    // Handle non-streaming response
                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    if (data.choices && data.choices[0]) {
                        const content = data.choices[0].message.content;
                        const assistantMessage = createMessageWithCopy(content, 'assistant-message');
                        assistantMessage.dataset.panelId = panel.id;
                        chatWindow.appendChild(assistantMessage);
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                    } else {
                        throw new Error('Invalid response format from server');
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                const errorMessage = createMessageWithCopy('Error: ' + error.message, 'error-message');
                chatWindow.appendChild(errorMessage);
                chatWindow.scrollTop = chatWindow.scrollHeight;
            } finally {
                // Re-enable the send button, hide stop button
                sendButton.disabled = false;
                stopButton.style.display = 'none';
                
                // Remove analyzing animation if it exists
                const analyzingElement = chatWindow.querySelector('.analyzing-container');
                if (analyzingElement) {
                    analyzingElement.remove();
                }
                
                // Dispatch event to notify that the response is complete
                const event = new CustomEvent('responseComplete', {
                    detail: { panelId: panel.id }
                });
                document.dispatchEvent(event);
            }
        }
        
        // Function to check if we can send in sequential mode
        function canSendInSequentialMode(currentPanel) {
            const processingMode = document.getElementById('processingMode').value;
            console.log("Checking if can send in sequential mode. Current mode:", processingMode);
            
            // If not in sequential mode, always allow
            if (processingMode !== 'sequential') {
                console.log("Not in sequential mode, allowing send");
                return true;
            }
            
            // Get all panels
            const panels = Array.from(document.querySelectorAll('.chat-panel'));
            const currentIndex = panels.indexOf(currentPanel);
            console.log("Current panel index:", currentIndex, "Total panels:", panels.length);
            
            // First panel can always send
            if (currentIndex === 0) {
                console.log("First panel, allowing send");
                return true;
            }
            
            // Check if the previous panel has received a response
            const previousPanel = panels[currentIndex - 1];
            const previousPanelMessages = previousPanel.querySelectorAll('.message');
            console.log("Previous panel has", previousPanelMessages.length, "messages");
            
            // If the previous panel has no messages at all, we can't send
            if (previousPanelMessages.length === 0) {
                console.log("Previous panel has no messages, blocking send");
                return false;
            }
            
            // Check if the last message in the previous panel is from the assistant
            const lastMessage = previousPanelMessages[previousPanelMessages.length - 1];
            const isLastMessageFromAssistant = !lastMessage.classList.contains('user-message');
            console.log("Last message is from assistant:", isLastMessageFromAssistant);
            
            // Check if there's a pending response in the previous panel
            const previousStopButton = previousPanel.querySelector('.stop-button');
            const hasPendingResponse = previousStopButton && previousStopButton.style.display !== 'none';
            console.log("Previous panel has pending response:", hasPendingResponse);
            
            // Can send if the last message is from the assistant and there's no pending response
            const canSend = isLastMessageFromAssistant && !hasPendingResponse;
            console.log("Can send in sequential mode:", canSend);
            return canSend;
        }

        // Function to set up sequential monitoring
        function setupSequentialMonitoring() {
            console.log("Setting up sequential monitoring");
            
            // Remove existing event listener if any
            document.removeEventListener('responseComplete', handleResponseComplete);
            
            // Add new event listener
            document.addEventListener('responseComplete', handleResponseComplete);
            
            // Log that the event listener is registered
            console.log("Sequential mode event listener registered");
        }
        
        // Function to handle response complete event
        function handleResponseComplete(e) {
            console.log("Response complete event received for panel:", e.detail.panelId);
            
            const processingMode = document.getElementById('processingMode').value;
            console.log("Current processing mode:", processingMode);
            
            if (processingMode !== 'sequential') {
                console.log("Not in sequential mode, ignoring response complete event");
                return;
            }
            
            const panels = Array.from(document.querySelectorAll('.chat-panel'));
            const currentPanelIndex = panels.findIndex(panel => panel.id === e.detail.panelId);
            console.log("Current panel index:", currentPanelIndex, "Total panels:", panels.length);
            
            // If this is not the last panel, trigger the next one
            if (currentPanelIndex < panels.length - 1) {
                const currentPanel = panels[currentPanelIndex];
                const nextPanel = panels[currentPanelIndex + 1];
                console.log("Next panel id:", nextPanel.id);
                
                // Get all messages from the current panel
                const messages = Array.from(currentPanel.querySelectorAll('.message'));
                
                // Extract the entire conversation history
                let conversationHistory = [];
                messages.forEach(message => {
                    const isUser = message.classList.contains('user-message');
                    const sender = isUser ? "User" : message.querySelector('.message-sender').textContent;
                    const content = message.querySelector('.message-content').textContent;
                    
                    conversationHistory.push({
                        role: isUser ? "user" : "assistant",
                        sender: sender,
                        content: content
                    });
                });
                
                console.log(`Extracted ${conversationHistory.length} messages from conversation history`);
                
                // Only proceed if we have messages
                if (conversationHistory.length > 0) {
                    // Format the conversation history in a clearer way for the model
                    let formattedHistory = "# Previous Conversation\n\n";
                    
                    conversationHistory.forEach(msg => {
                        formattedHistory += `## ${msg.sender}:\n${msg.content}\n\n`;
                    });
                    
                    // Add instructions for the next assistant
                    const nextPanelTitle = nextPanel.querySelector('.panel-header h5').textContent;
                    formattedHistory += `# Instructions\n\nYou are a ${nextPanelTitle}. Continue the conversation based on the previous context.\n`;
                    formattedHistory += `You should build on what the previous assistant has said, but bring your own expertise and perspective.\n`;
                    formattedHistory += `Respond directly to the user's last message, taking into account the previous responses.\n\n`;
                    formattedHistory += `# Your Response\n`;
                    
                    console.log("Created formatted prompt for next panel with clear structure");
                    
                    // Set the prompt in the next panel
                    const nextTextarea = nextPanel.querySelector('.prompt-input');
                    if (nextTextarea) {
                        nextTextarea.value = formattedHistory;
                        
                        // Auto-adjust height with maximum limit of 2 lines (approx 70px)
                        nextTextarea.style.height = 'auto';
                        const maxHeight = 70; // Maximum height in pixels (approx 2 lines)
                        
                        // If content height exceeds max height, set to max and enable scrolling
                        if (nextTextarea.scrollHeight > maxHeight) {
                            nextTextarea.style.height = maxHeight + 'px';
                            nextTextarea.style.overflowY = 'auto';
                        } else {
                            nextTextarea.style.height = nextTextarea.scrollHeight + 'px';
                            nextTextarea.style.overflowY = 'hidden';
                        }
                        
                        // Ensure model is selected before sending
                        const nextModelSelect = nextPanel.querySelector('.model-select');
                        if (nextModelSelect && (!nextModelSelect.value || nextModelSelect.value === "")) {
                            console.warn("No model selected in next panel, selecting first available model");
                            if (window.availableModels && window.availableModels.length > 0) {
                                nextModelSelect.value = window.availableModels[0].id;
                            } else {
                                console.error("No models available to select");
                                return;
                            }
                        }
                        
                        // Scroll to the next panel to make it visible
                        nextPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        
                        // Simulate click on send button after a delay to ensure everything is ready
                        console.log("Will click send button in next panel after delay");
                        setTimeout(() => {
                            const sendButton = nextPanel.querySelector('.send-button');
                            if (sendButton && !sendButton.disabled) {
                                console.log("Clicking send button in panel:", nextPanel.id);
                                sendButton.click();
                            } else {
                                console.error("Send button not available or disabled in panel:", nextPanel.id);
                            }
                        }, 1000); // Reduced delay to 1 second for better responsiveness
                    } else {
                        console.error("Could not find textarea in next panel:", nextPanel.id);
                    }
                } else {
                    console.error("No conversation history found in panel:", currentPanel.id);
                }
            } else {
                console.log("This is the last panel, no next panel to trigger");
            }
        }
        
        // Function to fetch available models with retries
        function fetchModels(retryCount = 0, maxRetries = 3) {
            console.log(`Fetching models (attempt ${retryCount + 1}/${maxRetries + 1})...`);
            
            // Store current selections before updating
            const currentSelections = {};
            document.querySelectorAll('.model-select').forEach(select => {
                currentSelections[select.closest('.chat-panel').id] = select.value;
            });
            
            // Add loading indicator to the model selects
            document.querySelectorAll('.model-select').forEach(select => {
                select.innerHTML = '<option value="">Loading models...</option>';
            });
            
            fetch('/models', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ server_url: server_url })
            })
            .then(response => {
                console.log("Models API response status:", response.status);
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Models data received:", data);
                if (data.models && data.models.length > 0) {
                    // Store models globally
                    window.availableModels = data.models;
                    console.log("Available models:", window.availableModels);
                    
                    // Populate all model selects while preserving selections
                    document.querySelectorAll('.model-select').forEach(select => {
                        const panelId = select.closest('.chat-panel').id;
                        const previousSelection = currentSelections[panelId];
                        populateModelSelect(select, previousSelection);
                    });
                    
                    // Update upload button visibility for all panels
                    document.querySelectorAll('.chat-panel').forEach(panel => {
                        const uploadBtn = panel.querySelector('.upload-btn');
                        if (uploadBtn) {
                            uploadBtn.style.display = 'inline-flex';
                        }
                    });
                } else {
                    throw new Error('No models found in response');
                }
            })
            .catch(error => {
                console.error('Error fetching models:', error);
                
                // If we haven't exceeded max retries, try again after a delay
                if (retryCount < maxRetries) {
                    console.log(`Retrying in ${(retryCount + 1) * 2} seconds...`);
                    setTimeout(() => {
                        fetchModels(retryCount + 1, maxRetries);
                    }, (retryCount + 1) * 2000); // Exponential backoff
                } else {
                    console.error('Max retries exceeded');
                    document.querySelectorAll('.model-select').forEach(select => {
                        const panelId = select.closest('.chat-panel').id;
                        const previousSelection = currentSelections[panelId];
                        select.innerHTML = '<option value="">Error loading models</option>';
                        // Add a second option with the error message
                        const option = document.createElement('option');
                        option.value = "";
                        option.textContent = error.message;
                        option.disabled = true;
                        select.appendChild(option);
                        
                        // Try to restore previous selection if it exists in the error state
                        if (previousSelection) {
                            const restoreOption = document.createElement('option');
                            restoreOption.value = previousSelection;
                            restoreOption.textContent = previousSelection;
                            select.appendChild(restoreOption);
                            select.value = previousSelection;
                        }
                    });
                }
            });
        }

        // Function to populate model select
        function populateModelSelect(select, selectedModel = "") {
            console.log("Populating model select:", select, "with selected model:", selectedModel);
            
            // Clear existing options except the placeholder
            Array.from(select.options).forEach((option, index) => {
                if (index !== 0) option.remove();
            });
            
            // Set initial option
            select.options[0].textContent = "Select Model";
            
            // If we have models, add them
            if (window.availableModels && window.availableModels.length > 0) {
                console.log(`Adding ${window.availableModels.length} models to select`);
                window.availableModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    // If this is the model we want to select, set it as selected
                    if (model.id === selectedModel) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } else {
                console.warn("No models available to populate select");
            }
        }

        // Function to open summary modal
        function openSummaryModal() {
            console.log("Opening summary modal");
            
            // Get the modal element
            const modalElement = document.getElementById('summaryModal');
            if (!modalElement) {
                console.error('Summary modal element not found');
                return;
            }
            
            // Populate the model select dropdown
            populateSummaryModelSelect();
            
            // Show modal
            const modal = new bootstrap.Modal(modalElement);
            modal.show();
            
            // Add click event listener to the generate button
            const generateBtn = document.getElementById('generateSummaryBtn');
            if (!generateBtn) {
                console.error('Generate summary button not found');
                return;
            }
            
            // Remove any existing click handlers
            generateBtn.replaceWith(generateBtn.cloneNode(true));
            
            // Get the fresh reference after replacement
            const freshGenerateBtn = document.getElementById('generateSummaryBtn');
            freshGenerateBtn.onclick = function() {
                console.log("Generate Summary button clicked from modal");
                generateSummary();
            };
        }
        
        // Function to populate summary model select
        function populateSummaryModelSelect() {
            const select = document.getElementById('summaryModel');
            if (!select) {
                console.error('Summary model select element not found');
                return;
            }
            
            // Clear all existing options
            select.innerHTML = '';
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select Model';
            select.appendChild(defaultOption);
            
            // If we have models, add them
            if (window.availableModels && window.availableModels.length > 0) {
                console.log(`Adding ${window.availableModels.length} models to summary select`);
                window.availableModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    select.appendChild(option);
                });
                
                // Select the first model by default
                if (select.options.length > 1) {
                    select.selectedIndex = 1;
                }
            } else {
                console.warn("No models available for summary generation");
                const noModelsOption = document.createElement('option');
                noModelsOption.value = '';
                noModelsOption.textContent = 'No models available';
                noModelsOption.disabled = true;
                select.appendChild(noModelsOption);
                
                const checkConnectionOption = document.createElement('option');
                checkConnectionOption.value = '';
                checkConnectionOption.textContent = 'Check server connection';
                checkConnectionOption.disabled = true;
                select.appendChild(checkConnectionOption);
            }
        }
        
        // Function to generate summary
        function generateSummary() {
            const selectedModel = document.getElementById('summaryModel').value;
            const summaryType = document.getElementById('summaryType').value;
            
            if (!selectedModel) {
                alert('Please select a model for summarization');
                return;
            }
            
            // Show spinner and hide previous result
            document.getElementById('summarySpinner').style.display = 'block';
            document.getElementById('summaryResult').style.display = 'none';
            
            // Get all panels
            const allPanels = Array.from(document.querySelectorAll('.chat-panel'));
            
            // Collect all messages with timestamps and panel info
            const allMessages = [];
            
            allPanels.forEach((panel, panelIndex) => {
                const panelRole = panel.querySelector('.role-select').value;
                const panelPosture = panel.querySelector('.posture-select').value;
                const panelTitle = `${panelPosture} ${panelRole}`;
                
                // Get all messages from this panel
                const messages = Array.from(panel.querySelectorAll('.message'));
                messages.forEach((message, messageIndex) => {
                    const isUser = message.classList.contains('user-message');
                    const content = message.querySelector('.message-content').textContent;
                    const timestamp = new Date().toLocaleString(); // In a real app, you'd store actual timestamps
                    
                    allMessages.push({
                        panel: panelIndex + 1,
                        panelTitle: panelTitle,
                        messageIndex: messageIndex + 1,
                        role: isUser ? 'user' : 'assistant',
                        sender: isUser ? 'User' : panelTitle,
                        content: content,
                        timestamp: timestamp,
                        type: isUser ? 'question' : 'response'
                    });
                });
            });
            
            if (allMessages.length === 0) {
                alert('No messages found to summarize');
                document.getElementById('summarySpinner').style.display = 'none';
                return;
            }
            
            // Format the conversation history for the summary
            const formattedHistory = allMessages.map(msg => {
                if (msg.type === 'question') {
                    return `Question (${msg.timestamp}):\n${msg.content}`;
                } else {
                    return `Response from ${msg.panelTitle} (${msg.timestamp}):\n${msg.content}`;
                }
            }).join('\n\n');
            
            console.log('Generating summary with:', {
                model: selectedModel,
                summaryType: summaryType,
                messageCount: allMessages.length
            });
            
            // Send to server for summarization
            fetch('/summarize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    conversation: allMessages,
                    model: selectedModel,
                    summaryType: summaryType,
                    server_url: server_url
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.message || `Server returned ${response.status}: ${response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('Summary received:', data);
                // Hide spinner
                document.getElementById('summarySpinner').style.display = 'none';
                
                // Create container for the summary
                const summaryDiv = document.createElement('div');
                
                if (summaryType === 'whatsapp') {
                    // WhatsApp style formatting
                    summaryDiv.className = 'whatsapp-summary';
                    
                    // Add title and timestamp
                    const title = document.createElement('div');
                    title.className = 'title';
                    title.textContent = 'Conversation Summary';
                    summaryDiv.appendChild(title);
                    
                    const timestamp = document.createElement('div');
                    timestamp.className = 'timestamp';
                    timestamp.textContent = new Date().toLocaleString();
                    summaryDiv.appendChild(timestamp);
                    
                    // Add interaction count
                    const stats = document.createElement('div');
                    stats.className = 'section';
                    stats.innerHTML = `
                        <div class="item">ðŸ’¬ Total Interactions: ${allMessages.length}</div>
                        <div class="item">ðŸ‘¥ Participants: ${new Set(allMessages.map(m => m.panelTitle)).size + 1}</div>
                    `;
                    summaryDiv.appendChild(stats);
                    
                    // Add the summary content with WhatsApp formatting
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'section';
                    
                    // Format the summary text with emojis and WhatsApp styling
                    const formattedSummary = data.summary
                        .split('\n')
                        .map(line => {
                            if (!line.trim()) return '';
                            
                            if (line.match(/^[A-Z][\w\s]+:/)) {
                                return `<div class="section-title">${line}</div>`;
                            }
                            
                            if (line.trim().startsWith('-') || line.trim().startsWith('â€¢')) {
                                return `<div class="item">${line.replace(/^[-â€¢]/, 'ðŸ“Œ')}</div>`;
                            }
                            
                            if (line.includes(':')) {
                                return `<div class="item">${line}</div>`;
                            }
                            
                            return `<div class="item">${line}</div>`;
                        })
                        .filter(line => line)
                        .join('');
                    
                    contentDiv.innerHTML = formattedSummary;
                    summaryDiv.appendChild(contentDiv);
                } else {
                    // Regular text formatting for other summary types
                    summaryDiv.className = 'text-summary';
                    
                    // Add title and metadata
                    const title = document.createElement('div');
                    title.className = 'summary-title';
                    title.textContent = summaryType.charAt(0).toUpperCase() + summaryType.slice(1) + ' Summary';
                    summaryDiv.appendChild(title);
                    
                    const metadata = document.createElement('div');
                    metadata.className = 'summary-metadata';
                    metadata.innerHTML = `
                        <div>Generated: ${new Date().toLocaleString()}</div>
                        <div>Total Interactions: ${allMessages.length}</div>
                        <div>Participants: ${new Set(allMessages.map(m => m.panelTitle)).size + 1}</div>
                    `;
                    summaryDiv.appendChild(metadata);
                    
                    // Add content with appropriate formatting
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'summary-content';
                    
                    // Format based on summary type
                    const lines = data.summary.split('\n');
                    const formattedLines = lines.map(line => {
                        if (!line.trim()) return '';
                        
                        if (summaryType === 'bullet' && (line.trim().startsWith('-') || line.trim().startsWith('â€¢'))) {
                            return `<div class="bullet-point">${line}</div>`;
                        }
                        
                        if (line.match(/^[A-Z][\w\s]+:/)) {
                            return `<div class="section-header">${line}</div>`;
                        }
                        
                        return `<div class="text-line">${line}</div>`;
                    }).filter(line => line);
                    
                    contentDiv.innerHTML = formattedLines.join('');
                    summaryDiv.appendChild(contentDiv);
                }
                
                // Display the summary
                document.getElementById('summaryResult').style.display = 'block';
                const summaryContent = document.getElementById('summaryContent');
                summaryContent.innerHTML = '';
                summaryContent.appendChild(summaryDiv);
                
                // Setup copy button
                const copyBtn = document.getElementById('copySummaryBtn');
                copyBtn.onclick = function() {
                    navigator.clipboard.writeText(summaryDiv.innerText)
                        .then(() => {
                            this.innerHTML = '<i class="bi bi-check"></i> Copied';
                            setTimeout(() => {
                                this.innerHTML = '<i class="bi bi-clipboard"></i> Copy';
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Failed to copy summary:', err);
                            alert('Failed to copy summary to clipboard');
                        });
                };
            })
            .catch(error => {
                console.error('Error generating summary:', error);
                document.getElementById('summarySpinner').style.display = 'none';
                alert('Error generating summary: ' + error.message);
            });
        }
        
        // Function to export conversations (kept for reference/future use)
        function exportConversations() {
            const conversations = [];
            
            // For each panel, gather the conversation
            document.querySelectorAll('.chat-panel').forEach(panel => {
                const panelId = panel.id;
                const modelName = panel.querySelector('.model-select').value || 'Unknown Model';
                const messages = [];
                
                // Get all messages
                panel.querySelectorAll('.message').forEach(message => {
                    const isUser = message.classList.contains('user-message');
                    const content = message.querySelector('.message-content').textContent;
                    messages.push({
                        role: isUser ? 'user' : 'assistant',
                        content: content
                    });
                });

                conversations.push({
                    panel: panelId,
                    model: modelName,
                    messages: messages
                });
            });
            
            // Create a blob and download
            const blob = new Blob([JSON.stringify(conversations, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cochat-export-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function createMessageWithCopy(content, className) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${className}`;
            
            // Add sender info
            const senderDiv = document.createElement('div');
            senderDiv.className = 'message-sender';
            
            // Get role and posture
            let role = 'assistant';
            let posture = 'professional';
            
            if (className === 'user-message') {
                senderDiv.textContent = 'You';
            } else {
                try {
                    const activePanels = Array.from(document.querySelectorAll('.chat-panel')).filter(panel => 
                        panel.querySelector('.stop-button').style.display !== 'none'
                    );
                    
                    let activePanel;
                    if (activePanels.length > 0) {
                        activePanel = activePanels[0];
                    } else {
                        activePanel = document.activeElement ? 
                            document.activeElement.closest('.chat-panel') : null;
                        
                        if (!activePanel) {
                            const allPanels = Array.from(document.querySelectorAll('.chat-panel'));
                            activePanel = allPanels[allPanels.length - 1];
                        }
                    }
                    
                    if (activePanel) {
                        const roleSelect = activePanel.querySelector('.role-select');
                        const postureSelect = activePanel.querySelector('.posture-select');
                        
                        if (roleSelect && postureSelect) {
                            role = roleSelect.value;
                            posture = postureSelect.value;
                            senderDiv.textContent = `${role} (${posture})`;
                        } else {
                            senderDiv.textContent = 'Assistant';
                        }
                    } else {
                        senderDiv.textContent = 'Assistant';
                    }
                } catch (e) {
                    console.error('Error getting role/posture:', e);
                    senderDiv.textContent = 'Assistant';
                }
            }
            
            messageDiv.appendChild(senderDiv);
            
            // Add content
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Check for image/file references in the content
            const regex = /\[(Image|File):\s+([^\]]+)\]\(([^)]+)\)/g;
            let lastIndex = 0;
            let match;
            
            while ((match = regex.exec(content)) !== null) {
                // Add text before the match
                if (match.index > lastIndex) {
                    contentDiv.appendChild(document.createTextNode(content.substring(lastIndex, match.index)));
                }
                
                const [fullMatch, type, filename, url] = match;
                
                if (type === 'Image') {
                    // Create thumbnail container
                    const thumbContainer = document.createElement('div');
                    thumbContainer.className = 'image-thumbnail';
                    
                    // Create image element
                    const img = document.createElement('img');
                    img.src = url;
                    img.alt = filename;
                    img.title = filename;
                    
                    // Add click handler to open image in new tab
                    img.onclick = () => window.open(url, '_blank');
                    
                    thumbContainer.appendChild(img);
                    contentDiv.appendChild(thumbContainer);
                } else {
                    // Create file link
                    const link = document.createElement('a');
                    link.href = url;
                    link.target = '_blank';
                    link.textContent = `ðŸ“Ž ${filename}`;
                    link.className = 'file-link';
                    contentDiv.appendChild(link);
                }
                
                lastIndex = regex.lastIndex;
            }
            
            // Add remaining text
            if (lastIndex < content.length) {
                contentDiv.appendChild(document.createTextNode(content.substring(lastIndex)));
            }
            
            messageDiv.appendChild(contentDiv);
            
            // Add copy button
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.innerHTML = '<i class="bi bi-clipboard"></i>';
            copyButton.title = 'Copy text';
            copyButton.onclick = async (e) => {
                e.stopPropagation();
                try {
                    await navigator.clipboard.writeText(content);
                    copyButton.innerHTML = '<i class="bi bi-check"></i>';
                    setTimeout(() => {
                        copyButton.innerHTML = '<i class="bi bi-clipboard"></i>';
                    }, 1000);
                } catch (err) {
                    console.error('Failed to copy text:', err);
                }
            };
            
            messageDiv.appendChild(copyButton);
            return messageDiv;
        }

        function detectModelCapabilities(modelId) {
            if (!modelId) return { vision: false };
            
            const visionPatterns = [
                'vl',           // Qwen VL models
                'vision',       // Generic vision models
                'visual',       // Visual models
                'multimodal',   // Multimodal models
                'image',        // Image-capable models
                'ocr'          // OCR models like olmocr
            ];
            
            modelId = modelId.toLowerCase();
            const hasVisionCapability = visionPatterns.some(pattern => modelId.includes(pattern));
            
            return {
                vision: hasVisionCapability
            };
        }

        function updateUploadButtonVisibility(panel) {
            const modelSelect = panel.querySelector('.model-select');
            const uploadBtn = panel.querySelector('.upload-btn');
            const fileInput = panel.querySelector('.file-input');
            
            if (!modelSelect || !uploadBtn || !fileInput) return;
            
            const selectedModel = modelSelect.value;
            const capabilities = detectModelCapabilities(selectedModel);
            
            // Show upload button if model is selected
            uploadBtn.style.display = selectedModel ? 'inline-flex' : 'none';
            
            // Update file input accept attribute based on capabilities
            fileInput.accept = capabilities.vision ? 'image/*' : '*/*';
            
            // Update button tooltip
            uploadBtn.title = capabilities.vision ? 'Upload Image' : 'Upload File';
        }

        // Add this to your existing CSS
        const style = document.createElement('style');
        style.textContent = `
            .image-thumbnail {
                margin: 10px 0;
                display: inline-block;
                max-width: 200px;
                cursor: pointer;
            }
            
            .image-thumbnail img {
                max-width: 100%;
                border-radius: 5px;
                border: 1px solid #ddd;
                transition: transform 0.2s;
            }
            
            .image-thumbnail img:hover {
                transform: scale(1.05);
            }
            
            .file-link {
                display: inline-block;
                padding: 5px 10px;
                margin: 5px 0;
                background: #f5f5f5;
                border-radius: 4px;
                text-decoration: none;
                color: #333;
            }
            
            .file-link:hover {
                background: #e9e9e9;
            }
        `;
        document.head.appendChild(style);

        // Function to setup chat mode handlers
        function setupChatModeHandlers() {
            const modeDropdown = document.querySelector('.dropdown-menu');
            const currentModeSpan = document.getElementById('currentMode');
            const processingModeSelect = document.getElementById('processingMode');
            
            if (modeDropdown && currentModeSpan && processingModeSelect) {
                modeDropdown.addEventListener('click', function(e) {
                    if (e.target.classList.contains('dropdown-item')) {
                        e.preventDefault();
                        const mode = e.target.dataset.mode;
                        currentModeSpan.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
                        processingModeSelect.value = mode;
                        
                        // Setup sequential monitoring if needed
                        if (mode === 'sequential') {
                            setupSequentialMonitoring();
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>
